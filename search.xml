<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>hexo更换next主题及部分配置功能的启用</title>
    <url>/2020/11/18/hexo%E6%9B%B4%E6%8D%A2next%E4%B8%BB%E9%A2%98%E5%8F%8A%E9%83%A8%E5%88%86%E9%85%8D%E7%BD%AE%E5%8A%9F%E8%83%BD%E7%9A%84%E5%90%AF%E7%94%A8/</url>
    <content><![CDATA[<p>默认hexo博客框架使用的主题是landscape，而每个人对自己页面主题样式文本的喜好不同，所以接下来通过next主题案例来介绍如何更换主题及部分配置功能启用。更多主题参考链接：<a href="https://hexo.io/themes/">https://hexo.io/themes/</a> </p>
<a id="more"></a>

<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><ul>
<li><p>已经生成hexo博客主页（可以参考我的上一篇博客）</p>
</li>
<li><p>代码编辑器（sublime、vscode等）</p>
</li>
<li><p>支持MarkDown语言的编辑器（推荐Typora）</p>
</li>
</ul>
<p>注：站点配置文件指的是博客文件夹根目录中的_config.yml，主题配置文件指的是next主题文件夹下的_config.yml</p>
<h1 id="下载、启用及配置next主题"><a href="#下载、启用及配置next主题" class="headerlink" title="下载、启用及配置next主题"></a>下载、启用及配置next主题</h1><h2 id="下载next主题"><a href="#下载next主题" class="headerlink" title="下载next主题"></a>下载next主题</h2><p>点击链接跳转到github页面下载next主题压缩包<a href="https://github.com/theme-next/hexo-theme-next">https://github.com/theme-next/hexo-theme-next</a></p>
<p>解压至站点（博客文件夹根目录）的 themes 目录下，并将解压后的文件夹名称更改为next。</p>
<h2 id="启用next主题"><a href="#启用next主题" class="headerlink" title="启用next主题"></a>启用next主题</h2><p>打开站点配置文件，推荐使用sublime, Ctrl+L快捷键输入theme找到 theme 字段，并将其值更改为 next（保证与themes文件夹下面next主题文件夹名字一致否则主题失效）。</p>
<p><img src="%E5%90%AF%E7%94%A8next%E4%B8%BB%E9%A2%98.jpg"></p>
<p>更改后在命令行中Ctrl+C打断正在运行的服务，hexo s重新启动服务器，并在浏览器中刷新输入命令行中的本地地址，当出现下面的页面说明更换主题成功。</p>
<p><img src="%E5%90%AF%E5%8A%A8%E6%88%90%E5%8A%9F.jpg"></p>
<p>注：根据个人意愿删除themes文件夹下的landscape主题。</p>
<h2 id="更改主题配置文件"><a href="#更改主题配置文件" class="headerlink" title="更改主题配置文件"></a>更改主题配置文件</h2><h3 id="更改主题为中文"><a href="#更改主题为中文" class="headerlink" title="更改主题为中文"></a>更改主题为中文</h3><p>在主题配置文件文件中找到language字段修改为zh-CN，如下图  </p>
<p><img src="zh-CN.jpg"></p>
<p>按顺序在命令行中执行命令hexo clean、hexo g、hexo s，重启服务器后刷新页面即可生效。</p>
<p>小小吐槽一下：这步本人遇到了一点小坑，官方网站配置的参考如下图</p>
<p><img src="%E5%AE%98%E6%96%B9zh.jpg"></p>
<p>然而配置完成后并没有生效，检查了一下next主题的根目录下的languages，发现有zh-CN.yml语言配置文件，于是值改成zh-CN后中文就生效了…</p>
<h3 id="增加标签页、分类页"><a href="#增加标签页、分类页" class="headerlink" title="增加标签页、分类页"></a>增加标签页、分类页</h3><p>打开主题配置文件，找到menu字段，将下图白色箭头所示的注释打开（直接删掉前面的#或者注释快捷键都可以），在首页刷新，就可以看到红色箭头所示的效果（但是此时点开标签会报错空内容）。  </p>
<p><img src="%E5%A2%9E%E5%8A%A0%E6%A0%87%E7%AD%BE%E9%A1%B5%E3%80%81%E5%88%86%E7%B1%BB%E9%A1%B5.jpg"></p>
<p>关掉博客服务，然后输入命令hexo n page tags</p>
<p>命令执行完成后会在source目录下新增一个tags文件夹，内容为一个名为index.md的文件，可以用Typora打开并编辑。</p>
<p><img src="newtags.jpg"></p>
<p>再开启服务，刷新后点开首页中的标签就会有内容了。</p>
<p>关掉服务，输入命令hexo n page categories，命令执行完成后会在source目录下新增一个categories文件夹，内容为一个名为index.md的文件，可以用Typora打开并编辑。</p>
<p><img src="newcategories.jpg"></p>
<p>再开启服务，刷新后点开首页中的分类就会有内容了。</p>
<h3 id="next主题页面布局样式更改"><a href="#next主题页面布局样式更改" class="headerlink" title="next主题页面布局样式更改"></a>next主题页面布局样式更改</h3><p>进入站点配置文件，找到Scheme 字段，根据自己的喜欢更改主题的样式（打开一个，将其他注释），每次修改完成后都可以在浏览器中刷新查看主题样式的变化。</p>
<p><img src="next%E4%B8%BB%E9%A2%98%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80%E6%A0%B7%E5%BC%8F%E6%9B%B4%E6%94%B9.jpg"></p>
<h3 id="设置主题的头像"><a href="#设置主题的头像" class="headerlink" title="设置主题的头像"></a>设置主题的头像</h3><p>在主题配置文件中查找avatar，url后面的#号去掉，并按照你自己头像的后缀更改此处的头像名后缀，在主题next下的\source\images文件夹中删掉avatar.gif，替换为你此处在url中的命名图片即可，刷新页面就会有头像显示。  </p>
<p><img src="%E8%AE%BE%E7%BD%AE%E4%B8%BB%E9%A2%98%E7%9A%84%E5%A4%B4%E5%83%8F.jpg"></p>
<h3 id="更改标题及作者"><a href="#更改标题及作者" class="headerlink" title="更改标题及作者"></a>更改标题及作者</h3><p>在站点配置文件中找到这几行，按需修改即可</p>
<p><img src="%E6%9B%B4%E6%94%B9%E6%A0%87%E9%A2%98%E5%8F%8A%E4%BD%9C%E8%80%85.jpg"></p>
<h3 id="启用左边社交栏链接"><a href="#启用左边社交栏链接" class="headerlink" title="启用左边社交栏链接"></a>启用左边社交栏链接</h3><p>在博客的_config.yml中找到这几行，按需修改即可  </p>
<p><img src="%E5%90%AF%E7%94%A8%E5%B7%A6%E4%BE%A7%E7%A4%BE%E4%BA%A4%E6%A0%8F%E9%93%BE%E6%8E%A5.jpg"></p>
<p> 如果有什么问题或者技术交流，欢迎在博客首页左下角社交或者下方发布渠道二维码与我联系。 </p>
]]></content>
      <categories>
        <category>从0搭建博客及美化</category>
      </categories>
      <tags>
        <tag>hexo更换主题</tag>
        <tag>next主题</tag>
        <tag>next主题配置功能启用</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo+next主题样式美化</title>
    <url>/2020/11/18/hexo-next%E4%B8%BB%E9%A2%98%E6%A0%B7%E5%BC%8F%E7%BE%8E%E5%8C%96/</url>
    <content><![CDATA[<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>首先新建一篇文章，在命令行输入：hexo n “文章名”，就会在博客的根目录的\source_posts下面新增一篇命名的文章，此时就可以使用Typora编辑器写博客了。</p>
 <a id="more"></a> 

<h1 id="主页设置阅读全文"><a href="#主页设置阅读全文" class="headerlink" title="主页设置阅读全文"></a>主页设置阅读全文</h1><p>目前我在新版的next主题配置文件中还没找到这一项的开启方法，但是可以通过对md文章中增加一个下面的这个标签即可</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!--more--&gt; </span><br></pre></td></tr></table></figure>

<p>比如：</p>
<p><img src="%E8%AE%BE%E7%BD%AE%E9%98%85%E8%AF%BB%E5%85%A8%E6%96%87.jpg"></p>
<h1 id="设置动态背景"><a href="#设置动态背景" class="headerlink" title="设置动态背景"></a>设置动态背景</h1><p>在next/layout/_layout.swig的body结束标签之前加入这几行代码  （由于我的博客使用的是next主题，因此next是在博客根目录下themes里面的文件夹）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;% <span class="keyword">if</span> theme.canvas_nest %&#125;</span><br><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span> src=<span class="string">&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后在主题配置文件中的末尾加入  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">canvas_nest: true</span><br></pre></td></tr></table></figure>

<p>然后分别执行命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<p>重启服务器后，刷新页面就会出现动态背景的效果  </p>
<h1 id="添加右上角的fork-Github的小猫"><a href="#添加右上角的fork-Github的小猫" class="headerlink" title="添加右上角的fork Github的小猫"></a>添加右上角的fork Github的小猫</h1><p>在下面的地址中选择好样式后复制右边多行代码，打开next/layout/_layout.swig在</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;headband&quot;</span>&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>这个标签的下一行黏贴过去，把开头的url换成自己的github地址，然后命令行中输入命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<p><img src="Github%E7%9A%84%E5%B0%8F%E7%8C%AB.jpg"></p>
<h1 id="修改底部标签前面的-样式"><a href="#修改底部标签前面的-样式" class="headerlink" title="修改底部标签前面的#样式"></a>修改底部标签前面的#样式</h1><p>字体图标地址：<a href="https://fontawesome.com/icons?d=gallery&amp;q=fa-">https://fontawesome.com/icons?d=gallery&amp;q=fa-</a></p>
<p>打开next\layout_macro下面的post.swig，修改此处为i标签类名在网址中根据自己选择（需要在网址中选中并弹出字体图标网页，在图标的下面会有例如   fa fa-tag   字样，选中复制即可）。</p>
<p><img src="%E4%BF%AE%E6%94%B9%E5%BA%95%E9%83%A8%E6%A0%87%E7%AD%BE%E6%A0%B7%E5%BC%8F.jpg"></p>
<h1 id="来必力评论系统"><a href="#来必力评论系统" class="headerlink" title="来必力评论系统"></a>来必力评论系统</h1><p>官网：<a href="https://livere.com/">https://livere.com/</a></p>
<p>在官网注册后，在管理页面的代码管理中，复制一般网站栏代码中的data-uid后面的代码，然后粘贴到主题配置文件中对应的位子即可</p>
<p><img src="livere_uid.jpg"></p>
<h1 id="增加搜索功能"><a href="#增加搜索功能" class="headerlink" title="增加搜索功能"></a>增加搜索功能</h1><p>安装 hexo-generator-searchdb，在站点的根目录下执行以下命令：</p>
<p>npm install hexo-generator-searchdb –save</p>
<p>编辑根目录下的配置文件，新增以下内容到任意位置：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: <span class="number">10000</span></span><br></pre></td></tr></table></figure>

<p>编辑 主题配置文件，启用本地搜索功能：</p>
<p><img src="%E5%A2%9E%E5%8A%A0%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD.jpg"></p>
<h1 id="添加字数统计和阅读时长"><a href="#添加字数统计和阅读时长" class="headerlink" title="添加字数统计和阅读时长"></a>添加字数统计和阅读时长</h1><p>添加字数统计和阅读时长</p>
<p>命令行cd到根目录下执行     npm install hexo-symbols-count-time –save</p>
<p>如果安装完报如下提醒，还需安装eslint</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">D:\hexo\blog&gt;npm install hexo-symbols-count-time --save</span><br><span class="line">npm WARN babel-eslint@10.0.1 requires a peer of eslint@&gt;&#x3D; 4.12.1 but none is installed. You must install peer dependencies yourself.</span><br></pre></td></tr></table></figure>

<p>安装eslint      npm install eslint –save</p>
<p>在站点配置文件添加如下配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">symbols_count_time:</span><br><span class="line">  symbols: true                # 文章字数统计</span><br><span class="line">  time: true                   # 文章阅读时长</span><br><span class="line">  total_symbols: true          # 站点总字数统计</span><br><span class="line">  total_time: true             # 站点总阅读时长</span><br><span class="line">  exclude_codeblock: false     # 排除代码字数统计</span><br></pre></td></tr></table></figure>

<p>在NexT主题配置文件添加如下配置（NexT主题已支持该插件，有的话无需再添加）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Post wordcount display settings</span><br><span class="line"># Dependencies: https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;hexo-symbols-count-time</span><br><span class="line">symbols_count_time:</span><br><span class="line">  separated_meta: true     # 是否另起一行（true的话不和发表时间等同一行）</span><br><span class="line">  item_text_post: true     # 首页文章统计数量前是否显示文字描述（本文字数、阅读时长）</span><br><span class="line">  item_text_total: false   # 页面底部统计数量前是否显示文字描述（站点总字数、站点阅读时长）</span><br><span class="line">  awl: 4                   # Average Word Length</span><br><span class="line">  wpm: 275                 # Words Per Minute（每分钟阅读词数）</span><br><span class="line">  suffix: mins.</span><br></pre></td></tr></table></figure>

<p>完成后命令三连即可…</p>
<h1 id="加载动画"><a href="#加载动画" class="headerlink" title="加载动画"></a>加载动画</h1><p>github地址：<a href="https://github.com/theme-next/theme-next-pace">https://github.com/theme-next/theme-next-pace</a></p>
<p>先cd到next文件夹下，然后执行</p>
<p>git clone <a href="https://github.com/theme-next/theme-next-pace">https://github.com/theme-next/theme-next-pace</a> source/lib/pace</p>
<p>然后在主题的配置文件下设置true开启加载动画</p>
<p><img src="%E5%8A%A0%E8%BD%BD%E5%8A%A8%E7%94%BB.jpg"></p>
<h1 id="隐藏底部的强力驱动"><a href="#隐藏底部的强力驱动" class="headerlink" title="隐藏底部的强力驱动"></a>隐藏底部的强力驱动</h1><p>最新的next主题，在主题配置文件下改power为false即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Powered by Hexo &amp; NexT</span><br><span class="line"> powered: false</span><br></pre></td></tr></table></figure>

<h1 id="更换页面的背景图片"><a href="#更换页面的背景图片" class="headerlink" title="更换页面的背景图片"></a>更换页面的背景图片</h1><p>首先在主题配置文件中找到custom_file_path字段，将最后一行的注释解开  </p>
<p><img src="%E6%9B%B4%E6%8D%A2%E9%A1%B5%E9%9D%A2%E7%9A%84%E8%83%8C%E6%99%AF%E5%9B%BE%E7%89%87.jpg"></p>
<p>在博客的根目录下source文件夹下新建文件夹名为_data，然后在_data文件夹下新建文件styles，将其后缀改为styl，然后将下面代码写入写入此新建文件中，并且在主题文件夹下source的images里面放一张背景图，名为background.jpg（名与下面代码中url中文件名一致）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">body &#123;</span><br><span class="line"> 	background:url(<span class="regexp">/images/</span>background.jpg);</span><br><span class="line"> 	background-repeat: no-repeat;</span><br><span class="line">    background-attachment:fixed;</span><br><span class="line">    background-position:<span class="number">50</span>% <span class="number">50</span>%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重启服务器即可  </p>
<p>但是由于我们文章是不透明的，影响了我们的美观，我们还得修改一下透明度（代码如下，依旧放在styles.styl文件内）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">.content-wrap &#123;</span><br><span class="line">  opacity: <span class="number">0.9</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.sidebar &#123;</span><br><span class="line">  opacity: <span class="number">0.9</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.header-inner &#123;</span><br><span class="line">  background: rgba(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>,<span class="number">0.9</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.popup &#123;</span><br><span class="line">  opacity: <span class="number">0.9</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完毕后分别输入命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<h1 id="回到顶部"><a href="#回到顶部" class="headerlink" title="回到顶部"></a>回到顶部</h1><p>在主题配置文件中搜索back2top:，我们可以看到共有三个可选配置项。其作用分别如下。  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">back2top:</span><br><span class="line">  # 开启右下角的回到顶部箭头</span><br><span class="line">  enable: true</span><br><span class="line">  # 将回到顶部按钮改到侧边栏下方</span><br><span class="line">  sidebar: false</span><br><span class="line">  # 回到顶部不止显示箭头，也显示阅读进度百分比</span><br><span class="line">  scrollpercent: true</span><br></pre></td></tr></table></figure>

<h1 id="next主题的点击爱心"><a href="#next主题的点击爱心" class="headerlink" title="next主题的点击爱心"></a>next主题的点击爱心</h1><p>创建js文件</p>
<p>在/themes/next/source/js/src下新建文件clicklove.js，接着把该代码拷贝粘贴到clicklove.js文件中。<br> 代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">!<span class="function"><span class="keyword">function</span>(<span class="params">e,t,a</span>)</span>&#123;<span class="function"><span class="keyword">function</span> <span class="title">n</span>(<span class="params"></span>)</span>&#123;c(<span class="string">&quot;.heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: &#x27;&#x27;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;&quot;</span>),o(),r()&#125;<span class="function"><span class="keyword">function</span> <span class="title">r</span>(<span class="params"></span>)</span>&#123;<span class="keyword">for</span>(<span class="keyword">var</span> e=<span class="number">0</span>;e&lt;d.length;e++)d[e].alpha&lt;=<span class="number">0</span>?(t.body.removeChild(d[e].el),d.splice(e,<span class="number">1</span>)):(d[e].y--,d[e].scale+=<span class="number">.004</span>,d[e].alpha-=<span class="number">.013</span>,d[e].el.style.cssText=<span class="string">&quot;left:&quot;</span>+d[e].x+<span class="string">&quot;px;top:&quot;</span>+d[e].y+<span class="string">&quot;px;opacity:&quot;</span>+d[e].alpha+<span class="string">&quot;;transform:scale(&quot;</span>+d[e].scale+<span class="string">&quot;,&quot;</span>+d[e].scale+<span class="string">&quot;) rotate(45deg);background:&quot;</span>+d[e].color+<span class="string">&quot;;z-index:99999&quot;</span>);requestAnimationFrame(r)&#125;<span class="function"><span class="keyword">function</span> <span class="title">o</span>(<span class="params"></span>)</span>&#123;<span class="keyword">var</span> t=<span class="string">&quot;function&quot;</span>==<span class="keyword">typeof</span> e.onclick&amp;&amp;e.onclick;e.onclick=<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;t&amp;&amp;t(),i(e)&#125;&#125;<span class="function"><span class="keyword">function</span> <span class="title">i</span>(<span class="params">e</span>)</span>&#123;<span class="keyword">var</span> a=t.createElement(<span class="string">&quot;div&quot;</span>);a.className=<span class="string">&quot;heart&quot;</span>,d.push(&#123;<span class="attr">el</span>:a,<span class="attr">x</span>:e.clientX-<span class="number">5</span>,<span class="attr">y</span>:e.clientY-<span class="number">5</span>,<span class="attr">scale</span>:<span class="number">1</span>,<span class="attr">alpha</span>:<span class="number">1</span>,<span class="attr">color</span>:s()&#125;),t.body.appendChild(a)&#125;<span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params">e</span>)</span>&#123;<span class="keyword">var</span> a=t.createElement(<span class="string">&quot;style&quot;</span>);a.type=<span class="string">&quot;text/css&quot;</span>;<span class="keyword">try</span>&#123;a.appendChild(t.createTextNode(e))&#125;<span class="function"><span class="title">catch</span>(<span class="params">t</span>)</span>&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName(<span class="string">&quot;head&quot;</span>)[<span class="number">0</span>].appendChild(a)&#125;<span class="function"><span class="keyword">function</span> <span class="title">s</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span><span class="string">&quot;rgb(&quot;</span>+~~(<span class="number">255</span>*<span class="built_in">Math</span>.random())+<span class="string">&quot;,&quot;</span>+~~(<span class="number">255</span>*<span class="built_in">Math</span>.random())+<span class="string">&quot;,&quot;</span>+~~(<span class="number">255</span>*<span class="built_in">Math</span>.random())+<span class="string">&quot;)&quot;</span>&#125;<span class="keyword">var</span> d=[];e.requestAnimationFrame=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;<span class="built_in">setTimeout</span>(e,<span class="number">1e3</span>/<span class="number">60</span>)&#125;&#125;(),n()&#125;(<span class="built_in">window</span>,<span class="built_in">document</span>);</span><br></pre></td></tr></table></figure>

<p>修改_layout.swig，在\themes\next\layout_layout.swig文件末尾添加：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!-- 页面点击小红心 --&gt;</span><br><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span> src=<span class="string">&quot;/js/src/clicklove.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>命令行分别输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<p>完成后刷新页面即可。</p>
<p>后续有其他的美化操作会继续更新…</p>
<p>如果有什么问题或者技术交流，欢迎在下方发布渠道二维码联系我或者文章底部留言。 </p>
]]></content>
      <categories>
        <category>从0搭建博客及美化</category>
      </categories>
      <tags>
        <tag>hexo新增博客文章</tag>
        <tag>next主题美化</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo框架搭建个人博客</title>
    <url>/2020/11/18/hexo%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>搭建前的准备工作</p>
<p>在搭建博客开始之前，你必须已经</p>
<a id="more"></a>

<ul>
<li><p>有一个github/gitee账号，没有的话去注册一个；</p>
</li>
<li><p>安装了node.js（博客是基于node.js搭建的）、npm（这两步相对简单百度即可，npm -v验证是否安装成功）；</p>
</li>
<li><p>切换npm的淘宝镜像源（为了加快下载包的速度，不然npm的下载速度会非常非常慢，如能忍受这一步可忽略）</p>
<p>淘宝镜像源是基于npm安装好的情况下，在cmd或者powershell命令行中执行以下命令：</p>
<p>npm install –g cnpm –registry=<a href="http://registry.npm.taobao.org/">http://registry.npm.taobao.org</a>  </p>
<p>安装成功后 cnpm -v可查看当前是否安装成功，出现cnpm的版本号即为安装成功。</p>
</li>
</ul>
<h1 id="搭建hexo博客"><a href="#搭建hexo博客" class="headerlink" title="搭建hexo博客"></a>搭建hexo博客</h1><h2 id="全局安装hexo博客框架"><a href="#全局安装hexo博客框架" class="headerlink" title="全局安装hexo博客框架"></a>全局安装hexo博客框架</h2><p>说明：如果你没有安装cnpm，那么接下来的命令行中的cnpm要用npm代替，这里默认你已经安装cnpm。</p>
<p>在powershell（个人比较习惯用）或者cmd命令行中全局安装hexo，输入命令：cnpm install -g hexo-cli</p>
<p>如果出现红色英文或者很长时间命令行没有反应，可以Ctrl+C打断这次安装操作，解决办法：</p>
<ul>
<li>如果没有切换淘宝镜像源可以按照上面的准备工作中的方法切换</li>
<li>重新执行此次命令</li>
<li>如果是笔记本连手机热点（我自己很多次就是这样解决的…）</li>
</ul>
<h2 id="使用hexo生成博客"><a href="#使用hexo生成博客" class="headerlink" title="使用hexo生成博客"></a>使用hexo生成博客</h2><p>在新的文件夹下，打开powershell窗口（快捷键：shift+鼠标右键，列表中会有在此处打开powershell）</p>
<p>命令行中输入命令：hexo init  （过程非常简单，但是下载的时间比较长，耐心等待…）</p>
<p><em>提示：如果搭建博客过程中有问题，大不了把文件夹干掉重来，无需畏惧</em></p>
<p><img src="1.jpg"></p>
<p> 当出现Start blogging with Hexo！字样的时候表示博客已经安装完成  </p>
<p>这时候我们可以启动我们的博客</p>
<p>命令行：hexo s     （注：s为start的简写）</p>
<p><img src="2.jpg"></p>
<p>此时可以选中其中的地址，输入到浏览器中访问我们的博客 。</p>
<p> <img src="3.jpg"></p>
<p>此处默认使用的主题为landscape，可以根据自己不同的主题喜好更改（具体配置修改参考<a href="https://hexo.io/zh-cn/docs/themes.html%EF%BC%89">https://hexo.io/zh-cn/docs/themes.html）</a><br>这里默认为我们创建了第一篇文章。<br>标题名为Hello World，多么熟悉的语句~<br>文章简述了hexo怎样使用，可以简单的看一看。<br>顺便提一句，这里文章创作推荐使用Typora 这款Markdown的编辑器来写。</p>
<p>后续还会更新更换其他主题及页面样式的美化。</p>
<p>如果有什么问题或者技术交流，欢迎在博客首页左下角社交或者下方发布渠道二维码与我联系。</p>
]]></content>
      <categories>
        <category>从0搭建博客及美化</category>
      </categories>
      <tags>
        <tag>hexo框架</tag>
        <tag>博客搭建前的准备工作</tag>
      </tags>
  </entry>
  <entry>
    <title>PowerShell字符串缺少终止符错误</title>
    <url>/2020/12/01/powershell%E6%8A%A5%E5%AD%97%E7%AC%A6%E9%94%99%E7%BC%BA%E5%B0%91%E7%BB%88%E6%AD%A2%E7%AC%A6%E9%94%99%E8%AF%AF/</url>
    <content><![CDATA[<p>通常我打开某个文件夹 powershell 的方式是在这个文件夹下同时按 shift + 鼠标右键，但是今天在打开的时候 powershell 居然报了下面的错误：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">字符串缺少终止符: <span class="string">&#x27;。</span></span><br><span class="line"><span class="string">    + CategoryInfo          : ParserError: (:) [], ParentContainsErrorRecordException</span></span><br><span class="line"><span class="string">    + FullyQualifiedErrorId : TerminatorExpectedAtEndOfString</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>然后毫无以外的 powershell 文件夹切换也没成功。。。</p>
<p>直接 powershell 用切换命令，毫无意外的也跪了…</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /d <span class="string">&quot;D:\Chao&#x27;s Blog&#x27;&quot;</span></span><br></pre></td></tr></table></figure>

<p>看了一眼报错信息发现是没有终止字符，我的文件夹的名如下图</p>
<p><img src="image-20201201082804013.png" alt="image-20201201082804013"></p>
<p>原来是这个单引号 ‘ 搞的，<strong>先说解决方法</strong>，<strong>直接删掉这个 ‘s 前面的 ‘</strong> </p>
<p>如果此时末尾给个闭合的 ‘ , 会报如下的错误</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Set-Location</span> : 找不到接受实际参数“s”的位置形式参数。</span><br><span class="line">所在位置 行:<span class="number">1</span> 字符: <span class="number">1</span></span><br><span class="line">+ <span class="built_in">Set-Location</span> <span class="literal">-literalPath</span> <span class="string">&#x27;D:\Chao&#x27;</span>s Blog<span class="string">&#x27;&#x27;</span></span><br><span class="line">+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">    + CategoryInfo          : InvalidArgument: (:) [<span class="built_in">Set-Location</span>]，ParameterBindingException</span><br><span class="line">    + FullyQualifiedErrorId : PositionalParameterNotFound,Microsoft.PowerShell.Commands.SetLocationCommand</span><br></pre></td></tr></table></figure>

<p>所以平时我们命名文件夹，不建议加符号之类的。</p>
]]></content>
      <categories>
        <category>PowerShell命令行报错</category>
      </categories>
      <tags>
        <tag>PowerShell</tag>
        <tag>字符串缺少终止符</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面试刷题的方法和注意事项</title>
    <url>/2020/11/19/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98%E7%9A%84%E6%96%B9%E6%B3%95%E5%92%8C%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>针对我自己刷前端面试题方法效率低，刷过的题一看就会一做就废的这个毛病，我请教了一位几年前端工作经验并且为许多学生引过路的前辈，了解到了一些刷题的方法以及应该注意的问题。在这里我将这些方法记录并分享出来，希望能够帮助到正在刷题的你。</p>
<a id="more"></a>

<h1 id="刷题方法"><a href="#刷题方法" class="headerlink" title="刷题方法"></a>刷题方法</h1><p>这位前辈针对刷面试题方法一共提出了<strong>四点建议</strong>，分别是：</p>
<ul>
<li><p>遇到面试题，先看到的应该是题的考点，其次，脑子里都要思考四个问题</p>
<p>1.是什么 </p>
<p>2.原理</p>
<p>3.解决什么问题 </p>
<p>4.怎么用</p>
</li>
<li><p>会的题，应该怎么用有逻辑性的语言表达出来（建议分条）</p>
</li>
<li><p>每道题（如跨域）要会其主流的流程，并且以主流为重点说，其他的可以稍微提一下</p>
</li>
<li><p>这一点是在第二点的基础上，往自己开发的项目上靠，例如自己平时做项目的时候是用什么什么方法解决的。</p>
</li>
</ul>
<p>在平时刷题的时候养成这种好习惯，相信对刷题的效率一定会有所提升。</p>
<h1 id="刷题注意事项"><a href="#刷题注意事项" class="headerlink" title="刷题注意事项"></a>刷题注意事项</h1><p>这一块主要是自己平时逛社区看到的，总结了一下分享出来：</p>
<p><strong>1.大厂偏爱考察基础，特别是对于工作经验少的人，因此基础题一定要完全掌握</strong></p>
<p><strong>2.做不完的题海：以不变应万变，题可变，考点是不会变的，如Promis解决什么问题，这一定与异步有关</strong></p>
<h1 id="高效学习三步曲"><a href="#高效学习三步曲" class="headerlink" title="高效学习三步曲"></a>高效学习三步曲</h1><p>这块是慕课网上的老师讲到的，感觉讲的非常好，拿出来mark一下</p>
<ul>
<li><p><strong>找准知识体系</strong></p>
<p>这一步很重要很重要，也很难，这个知识体系是一个<strong>结构化的知识范围</strong>，就像一棵树一样，有根有树干，再往下分树枝、树叶这些，<strong>有组织</strong>，<strong>易扩展</strong>，这种知识体系便于我们的记忆（推荐<strong>思维导图</strong>）。</p>
</li>
<li><p><strong>刻意训练</strong></p>
<p>这一块不用多说，练就完事了！</p>
</li>
<li><p><strong>及时反馈</strong></p>
<p>可以通过在技术交流社区中写文章这种方式，总结输出自己的知识点，另一方面，如果写得好还会有人点赞，或者哪地方有进步的空间大家还可以互相交流。</p>
</li>
</ul>
<p>自己也搜罗整理了一些面试资料（包括面试的知识体系），如果有兴趣可以通过下方的二维码、留言或首页社交块与我联系。</p>
]]></content>
      <categories>
        <category>前端刷题</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>面试题</tag>
        <tag>刷题方法</tag>
        <tag>刷题注意事项</tag>
        <tag>高效学习三步曲</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面试题总结-JS-Web-API-DOM</title>
    <url>/2020/12/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93-JS-Web-API-DOM/</url>
    <content><![CDATA[<p>学会DOM，才能具备网页开发的基础</p>
<p>从 JS 基础知识到 JS Web API</p>
<ul>
<li>JS 基础知识，规定语法（ECMA 262 标准）</li>
<li>JS Web API，网页操作的 API （W3C 标准）</li>
<li>前者是后者的基础，两者结合才能真正实际应用</li>
</ul>
<a id="more"></a>

<p>JS 基础知识</p>
<ul>
<li>变量的类型和计算</li>
<li>原型和原型链</li>
<li>作用域和闭包</li>
</ul>
<p>JS Web API</p>
<ul>
<li>DOM 操作（网页的 DOM 元素）</li>
<li>BOM 操作（浏览器的导航、url 地址、跳转、宽高等）</li>
<li>事件绑定（监听一个点击等）</li>
<li>Ajax（发送一个网络请求）</li>
<li>存储</li>
</ul>
<h1 id="DOM-操作（Document-Object-Model）"><a href="#DOM-操作（Document-Object-Model）" class="headerlink" title="DOM 操作（Document Object Model）"></a>DOM 操作（Document Object Model）</h1><ul>
<li>vue 和 react 框架应用广泛，封装了 DOM 操作</li>
<li>但 DOM 操作一直都会是前端工程师的基础、必备知识</li>
<li>只会 vue 而不懂 DOM 操作的前端程序员，不会长久</li>
</ul>
<p>知识点</p>
<ul>
<li>DOM 本质</li>
<li>DOM 节点操作</li>
<li>DOM 结构操作</li>
<li>DOM 性能</li>
</ul>
<h2 id="DOM-本质"><a href="#DOM-本质" class="headerlink" title="DOM 本质"></a>DOM 本质</h2><p>本质就是从 HTML 语言解析出来的一棵树。</p>
<h2 id="DOM-节点操作"><a href="#DOM-节点操作" class="headerlink" title="DOM 节点操作"></a>DOM 节点操作</h2><p>1.获取 DOM 节点</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> div1 = <span class="built_in">document</span>.getElementById(<span class="string">&quot;div1&quot;</span>) <span class="comment">// 元素</span></span><br><span class="line"><span class="keyword">const</span> divList = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;div&quot;</span>) <span class="comment">// 元素</span></span><br><span class="line"><span class="built_in">console</span>.log(divList.length)</span><br><span class="line"><span class="built_in">console</span>.log(divList[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> containerList = <span class="built_in">document</span>.getElementsByClassName(<span class="string">&quot;.container&quot;</span>) <span class="comment">// 集合</span></span><br><span class="line"><span class="keyword">const</span> pList = <span class="built_in">document</span>.querySelectorAll(<span class="string">&quot;p&quot;</span>) <span class="comment">// 集合</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>DOM 节点的 property 和 attribute</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// property </span></span><br><span class="line"><span class="keyword">const</span> pList = <span class="built_in">document</span>.querySelectorAll(<span class="string">&quot;p&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> p = pList[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">console</span>.log(p.style.width) <span class="comment">// 获取样式</span></span><br><span class="line">p.style.width = <span class="string">&quot;100px&quot;</span> <span class="comment">// 修改样式</span></span><br><span class="line"><span class="built_in">console</span>.log(p.className) <span class="comment">// 获取 class</span></span><br><span class="line">p.className = <span class="string">&quot;p1&quot;</span> <span class="comment">// 修改class</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 nodeName 和 nodeType</span></span><br><span class="line"><span class="built_in">console</span>.log(p.nodeName)</span><br><span class="line"><span class="built_in">console</span>.log(p.nodeType)</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// attribute</span></span><br><span class="line"><span class="keyword">const</span> pList = <span class="built_in">document</span>.querySelectorAll(<span class="string">&quot;p&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> p = pList[<span class="number">0</span>]</span><br><span class="line">p.getAttribute(<span class="string">&quot;data-name&quot;</span>)</span><br><span class="line">p.setAttribute(<span class="string">&quot;data-name&quot;</span>, <span class="string">&quot;faker&quot;</span>)</span><br><span class="line">p.getAttribute(<span class="string">&quot;style&quot;</span>)</span><br><span class="line">p.setAttribute(<span class="string">&quot;style&quot;</span>, <span class="string">&quot;font-size:30px;&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="property-和-attribute"><a href="#property-和-attribute" class="headerlink" title="property 和 attribute"></a>property 和 attribute</h3><ul>
<li>property：修改对象属性，不会体现到 html 结构中</li>
<li>attribute：修改 html 属性，会改变 html 结构</li>
<li>两者都有可能引起 DOM 重新渲染</li>
</ul>
<h2 id="DOM-结构操作"><a href="#DOM-结构操作" class="headerlink" title="DOM 结构操作"></a>DOM 结构操作</h2><ul>
<li>新增/插入节点</li>
<li>获取子元素列表，获取父元素</li>
<li>删除子元素</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> div1 = <span class="built_in">document</span>.getElementById(<span class="string">&quot;div1&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加新节点</span></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="built_in">document</span>.createElement(<span class="string">&quot;p&quot;</span>)</span><br><span class="line">p1.innerHTML = <span class="string">&quot;this is p1&quot;</span></span><br><span class="line">div1.appendChild(p1) <span class="comment">// 添加新创建的元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 移动已有节点，注意是移动！！！</span></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="built_in">document</span>.getElementById(<span class="string">&quot;p2&quot;</span>)</span><br><span class="line">div1.appendChild(p2)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取子元素列表</span></span><br><span class="line"><span class="built_in">console</span>.log(div1.childNodes)</span><br><span class="line"><span class="comment">// 如果有 text 文本将其过滤</span></span><br><span class="line"><span class="keyword">const</span> div1ChildNodesP = <span class="built_in">Array</span>.prototype.slice.call(div1.childNodes).filters(<span class="function">(<span class="params">child</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (child.nodeType === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取父元素</span></span><br><span class="line"><span class="built_in">console</span>.log(p2.parentNode)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除节点</span></span><br><span class="line"><span class="keyword">const</span> div1 = <span class="built_in">document</span>.getElementById(<span class="string">&quot;div1&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> child = div1.childNodes</span><br><span class="line">div1.removeChild(child[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>

<h2 id="DOM-性能（重点）"><a href="#DOM-性能（重点）" class="headerlink" title="DOM 性能（重点）"></a>DOM 性能（重点）</h2><ul>
<li>DOM 操作非常“昂贵”（占用 CPU 比较多，有可能导致浏览器的重绘和重排），避免频繁的 DOM 操作</li>
<li>对 DOM 查询做缓存</li>
<li>将频繁操作改为一次性操作</li>
</ul>
<h3 id="DOM-查询做缓存"><a href="#DOM-查询做缓存" class="headerlink" title="DOM 查询做缓存"></a>DOM 查询做缓存</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不缓存 DOM 查询结果</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;p&quot;</span>).length; i++) &#123;</span><br><span class="line">    <span class="comment">// 每次循环，都会计算 length，频繁进行 DOM 查询</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 缓存 DOM 查询结果</span></span><br><span class="line"><span class="keyword">const</span> pList = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;p&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> length = pList.length</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="comment">// 缓存 length，只进行一次 DOM 查询</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="将频繁操作改为一次性操作"><a href="#将频繁操作改为一次性操作" class="headerlink" title="将频繁操作改为一次性操作"></a>将频繁操作改为一次性操作</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> listNode = <span class="built_in">document</span>.getElementById(<span class="string">&quot;list&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个文档片段，此时还没有插入到 DOM 树中</span></span><br><span class="line"><span class="keyword">const</span> frag = <span class="built_in">document</span>.createDocumentFragment()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行插入</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x = <span class="number">0</span>; x &lt; <span class="number">10</span>; x++) &#123;</span><br><span class="line">    <span class="keyword">const</span> li = <span class="built_in">document</span>.createElement(<span class="string">&quot;li&quot;</span>)</span><br><span class="line">    li.innerHTML = <span class="string">&quot;List item &quot;</span> + x</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 先插入文档片段中</span></span><br><span class="line">    frag.appendChild(li)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 都完成之后，再统一插入到 DOM 树中</span></span><br><span class="line">listNode.appendChild(frag)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也就是说，先建一个临时区域，把所有的高频操作都在临时区域中去插入</span></span><br><span class="line"><span class="comment">// 插入完成之后，再把临时区域一块放在 DOM 结构中，这样性能就会大大提升</span></span><br></pre></td></tr></table></figure>



<p><strong>DOM 是哪种数据结构</strong></p>
<ul>
<li>树型结构（DOM 树）</li>
</ul>
]]></content>
      <categories>
        <category>前端面试题</category>
      </categories>
      <tags>
        <tag>JS基础</tag>
        <tag>知识点总结</tag>
        <tag>JS-Web-API-DOM</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面试题总结-JS-Web-API-BOM</title>
    <url>/2020/12/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93-JS-Web-API-BOM/</url>
    <content><![CDATA[<p>内容虽然不多，但是不可不会</p>
<h1 id="BOM-操作-（Browser-Object-Model）"><a href="#BOM-操作-（Browser-Object-Model）" class="headerlink" title="BOM 操作 （Browser Object Model）"></a>BOM 操作 （Browser Object Model）</h1><p>这一块在面试中考点相对较少</p>
<a id="more"></a>

<p><strong>知识点</strong></p>
<ul>
<li><strong>navigator</strong></li>
<li>screen</li>
<li><strong>location</strong></li>
<li>history</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// navigator</span></span><br><span class="line"><span class="comment">// 识别浏览器类型</span></span><br><span class="line"><span class="keyword">const</span> ua = navigator.userAgent</span><br><span class="line"><span class="keyword">const</span> isEdge = ua.indexOf(<span class="string">&quot;Edg&quot;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(isEdge)</span><br><span class="line"></span><br><span class="line"><span class="comment">// screen</span></span><br><span class="line"><span class="built_in">console</span>.log(screen.width)   <span class="comment">// 浏览器屏幕宽度</span></span><br><span class="line"><span class="built_in">console</span>.log(screen.height)  <span class="comment">// 浏览器屏幕高度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// location</span></span><br><span class="line"><span class="built_in">console</span>.log(location.href)        <span class="comment">// 网址</span></span><br><span class="line"><span class="built_in">console</span>.log(location.protocol)    <span class="comment">// 协议</span></span><br><span class="line"><span class="built_in">console</span>.log(location.host)        <span class="comment">// 域名</span></span><br><span class="line"><span class="built_in">console</span>.log(location.pathname)    <span class="comment">// 浏览器路径</span></span><br><span class="line"><span class="built_in">console</span>.log(location.search)      <span class="comment">// 查询参数</span></span><br><span class="line"><span class="built_in">console</span>.log(location.hash)		  <span class="comment">// 哈希值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// history</span></span><br><span class="line">history.back()      <span class="comment">// 操作页面后退</span></span><br><span class="line">history.forward()   <span class="comment">// 操作页面前进</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端面试题</category>
      </categories>
      <tags>
        <tag>JS基础</tag>
        <tag>知识点总结</tag>
        <tag>JS-Web-API-BOM</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面试题总结-JS-Web-API-事件</title>
    <url>/2020/12/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93-JS-Web-API-%E4%BA%8B%E4%BB%B6/</url>
    <content><![CDATA[<p>事件不会，等于残废，必考！！！</p>
<h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><p><strong>知识点</strong></p>
<ul>
<li>事件绑定</li>
<li>事件冒泡</li>
<li>事件代理</li>
</ul>
<a id="more"></a>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 事件绑定</span></span><br><span class="line"><span class="keyword">const</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&quot;btn1&quot;</span>)</span><br><span class="line">btn.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;clicked&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通用的事件绑定函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bindEvent</span>(<span class="params">elem, type, fn</span>) </span>&#123;</span><br><span class="line">    elem.addEventListener(type, fn)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件冒泡</span></span><br><span class="line"><span class="comment">// 当子元素触发点击后，其父元素，或其所在的向上层级元素，都会截获点击事件</span></span><br><span class="line"><span class="keyword">const</span> body = <span class="built_in">document</span>.body</span><br><span class="line">bindEvent(body, <span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;body clicked&#x27;</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(event.target) <span class="comment">// 获取触发的元素</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阻止冒泡</span></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;p1&#x27;</span>)</span><br><span class="line">bindEvent(p1, <span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">    event.stopPropagation() <span class="comment">// 阻止冒泡</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;p1&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 事件代理</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// HTML</span></span><br><span class="line"><span class="comment">/* &lt;div id=&quot;div3&quot;&gt;</span></span><br><span class="line"><span class="comment">    &lt;a href=&quot;#&quot;&gt;a1&lt;/a&gt;&lt;br&gt;</span></span><br><span class="line"><span class="comment">    &lt;a href=&quot;#&quot;&gt;a2&lt;/a&gt;&lt;br&gt;</span></span><br><span class="line"><span class="comment">    &lt;a href=&quot;#&quot;&gt;a3&lt;/a&gt;&lt;br&gt;</span></span><br><span class="line"><span class="comment">    &lt;a href=&quot;#&quot;&gt;a4&lt;/a&gt;&lt;br&gt;</span></span><br><span class="line"><span class="comment">    &lt;button&gt;加载更多...&lt;/button&gt;</span></span><br><span class="line"><span class="comment">&lt;/div&gt; */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通用的事件绑定函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bindEvent</span>(<span class="params">elem, type, fn</span>) </span>&#123;</span><br><span class="line">    elem.addEventListener(type, fn)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理绑定</span></span><br><span class="line"><span class="comment">// 就是把事件绑定到一些不好每个都去绑定事件的情况</span></span><br><span class="line"><span class="comment">// 我们把它绑定到父元素上，然后做一些判断是否为我们想要的元素</span></span><br><span class="line"><span class="comment">// 然后再做其他的一些动作</span></span><br><span class="line"><span class="keyword">const</span> div3 = <span class="built_in">document</span>.getElementById(<span class="string">&quot;div3&quot;</span>)</span><br><span class="line">bindEvent(div3, <span class="string">&quot;click&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    event.preventDefault()</span><br><span class="line">    <span class="keyword">const</span> target = event.target</span><br><span class="line">    <span class="keyword">if</span> (target.nodeName === <span class="string">&quot;A&quot;</span>) &#123;</span><br><span class="line">        alert(target.innerHTML)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="事件代理"><a href="#事件代理" class="headerlink" title="事件代理"></a>事件代理</h2><ul>
<li>代码简洁</li>
<li>减少浏览器内存占用（如果 a 标签非常多的话，每个 a 标签都去挂一个事件，数量过多会非常耗费内存，但是我们只在父元素挂一次事件就不会耗费那么多内存）</li>
<li>但是，不要滥用（在瀑布流、结构复杂不好每一个都绑定事件的这种情况下去用）</li>
</ul>
<h2 id="通用的事件绑定函数-重点"><a href="#通用的事件绑定函数-重点" class="headerlink" title="通用的事件绑定函数(重点)"></a>通用的事件绑定函数(重点)</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通用的事件绑定函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bindEvent</span>(<span class="params">elem, type, selector, fn</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 判断传入参数个数</span></span><br><span class="line">    <span class="keyword">if</span> (fn == <span class="literal">null</span>) &#123;</span><br><span class="line">        fn = selector</span><br><span class="line">        selector = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    elem.addEventListener(type, <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> target = event.target</span><br><span class="line">        <span class="keyword">if</span> (selector) &#123;</span><br><span class="line">            <span class="comment">// 需要代理绑定</span></span><br><span class="line">            <span class="comment">// 判断一个 DOM 元素是不是符合一个 CSS 选择器</span></span><br><span class="line">            <span class="keyword">if</span> (target.matches(selector)) &#123;</span><br><span class="line">                fn.call(target, event)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; eles &#123;</span><br><span class="line">            <span class="comment">// 不需要代理绑定</span></span><br><span class="line">            fn.call(target, event)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><ul>
<li><p>编写一个通用的事件监听函数</p>
<p>参考上面代码</p>
</li>
</ul>
<ul>
<li><p>描述事件冒泡的流程</p>
<p>1.基于 DOM 树形结构</p>
<p>2.事件会顺着触发元素往上冒泡</p>
<p>3.应用场景：代理</p>
</li>
</ul>
<ul>
<li><p>无限下拉的图片列表，如何监听每个图片的点击</p>
<p>1.事件代理</p>
<p>2.用 event.target 获取触发元素</p>
<p>3.用 matches 来判断是否触发元素</p>
</li>
</ul>
]]></content>
      <categories>
        <category>前端面试题</category>
      </categories>
      <tags>
        <tag>JS基础</tag>
        <tag>知识点总结</tag>
        <tag>JS-Web-API-BOM</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面试题总结-JS-Web-API-存储</title>
    <url>/2020/12/08/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93-JS-Web-API-%E5%AD%98%E5%82%A8/</url>
    <content><![CDATA[<h1 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h1><p>知识点</p>
<ul>
<li>cookie</li>
<li>localStorage 和 session Storage</li>
</ul>
<a id="more"></a>

<h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><ul>
<li><p>本身用于浏览器和 server 通讯</p>
</li>
<li><p>被”借用”到本地存储</p>
</li>
<li><p>可用 document.cookie = ‘…’ 来修改</p>
</li>
</ul>
<h2 id="cookie-缺点"><a href="#cookie-缺点" class="headerlink" title="cookie 缺点"></a>cookie 缺点</h2><ul>
<li>存储大小，最大 4k</li>
<li>http 请求时需要发送到服务端，增加请求数据量</li>
<li>只能用 document.cookie = ‘…’ 来修改，太过简陋</li>
<li>cookie 的安全性过低</li>
</ul>
<h2 id="localStorage-和-sessionStorage"><a href="#localStorage-和-sessionStorage" class="headerlink" title="localStorage 和 sessionStorage"></a>localStorage 和 sessionStorage</h2><ul>
<li>HTML5 专门为存储而设计，最大可存 5M</li>
<li>API 简单易用 setItem、getItem</li>
<li>不会随着 http 请求被发送出去</li>
</ul>
<p><strong>二者区别</strong></p>
<ul>
<li>localStorage 数据会永久存储，除非代码或手动删除</li>
<li>sessionStorage 数据只存在于当前会话，浏览器关闭则清空</li>
<li>一般用 localStorage 会更多一些</li>
</ul>
<h1 id="描述-cookie、localStorage、sessionStorage区别"><a href="#描述-cookie、localStorage、sessionStorage区别" class="headerlink" title="描述 cookie、localStorage、sessionStorage区别"></a>描述 cookie、localStorage、sessionStorage区别</h1><ul>
<li>容量</li>
<li>API 易用性</li>
<li>是否跟随 http 请求发送出去</li>
</ul>
]]></content>
      <categories>
        <category>前端面试题</category>
      </categories>
      <tags>
        <tag>JS基础</tag>
        <tag>知识点总结</tag>
        <tag>JS-Web-API-Ajax</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面试题总结-JS-Web-API-Ajax</title>
    <url>/2020/12/08/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93-JS-Web-API-Ajax/</url>
    <content><![CDATA[<p>每个工程师都必须熟练掌握的技能</p>
<h1 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h1><h2 id="手写一个-XMLHttpRequest"><a href="#手写一个-XMLHttpRequest" class="headerlink" title="手写一个 XMLHttpRequest"></a>手写一个 XMLHttpRequest</h2><a id="more"></a>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// get 请求</span></span><br><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line"><span class="comment">// true 的意思是异步的请求, false 是同步</span></span><br><span class="line"><span class="comment">// 网络请求不能卡顿影响页面，所以需要异步</span></span><br><span class="line">xhr.open(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;./test.json&quot;</span>, <span class="literal">true</span>) </span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 必须三等</span></span><br><span class="line">    <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (xhr.status === <span class="number">200</span>) &#123;</span><br><span class="line">            alert(xhr.responseText)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;其他情况&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 由于是 get 请求，不用发送任何数据，直接 null 即可</span></span><br><span class="line">xhr.send(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// post 请求</span></span><br><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">xhr.open(<span class="string">&quot;POST&quot;</span>, <span class="string">&quot;./test.json&quot;</span>, <span class="literal">false</span>) </span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (xhr.status === <span class="number">200</span>) &#123;</span><br><span class="line">            alert(xhr.responseText)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;其他情况&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> postData = &#123;</span><br><span class="line">    name: <span class="string">&quot;zs&quot;</span>,</span><br><span class="line">    password: <span class="string">&quot;xxx&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将 json 数据变成字符串发送</span></span><br><span class="line">xhr.send(<span class="built_in">JSON</span>.stringify(postData))</span><br></pre></td></tr></table></figure>



<h2 id="xhr-readyState"><a href="#xhr-readyState" class="headerlink" title="xhr.readyState"></a>xhr.readyState</h2><ul>
<li>0 -（未初始化）还没有调用 send（）方法</li>
<li>1 -（载入）已调用 send（）方法，正在发送请求</li>
<li>2 -（载入完成）send（）方法执行完成，已经接收到全部响应内容</li>
<li>3 -（交互）正在解析响应内容</li>
<li>4 -（完成）响应内容解析完成，可以在客户端调用</li>
</ul>
<h2 id="xhr-status"><a href="#xhr-status" class="headerlink" title="xhr.status"></a>xhr.status</h2><ul>
<li>2xx - 表示成功处理请求，如 200</li>
<li>3xx - 需要重定向，浏览器直接跳转，如 301（永久重定向）、302（临时重定向）、304（资源未改变）</li>
<li>4xx - 客户端请求错误，如 404（请求地址有误，或者服务端没有）、403（客户端没有权限，在内部系统应用较多）</li>
<li>5xx - 服务器端错误（出 bug 了）</li>
</ul>
<h1 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h1><ul>
<li><p>什么是跨域（同源策略）</p>
<p><strong>同源策略</strong></p>
<ul>
<li>ajax 请求时，<strong>浏览器要求</strong>当前网页和 server 端必须同源（安全）</li>
<li>同源：协议、端口、域名，三者必须一致</li>
<li>前端: <a href="http://a.com:8080/">http://a.com:8080/</a> ；server: <a href="https://b.com/api/xxx">https://b.com/api/xxx</a> , 二者三个要求均不同</li>
</ul>
<p><strong>加载图片、CSS、JS 可无视同源策略</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;img src&#x3D;跨域的图片地址 &#x2F;&gt;</span><br><span class="line">&lt;link href&#x3D;跨域的图片地址 &#x2F;&gt;</span><br><span class="line">&lt;script src&#x3D;跨域的 JS 地址&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;img &#x2F;&gt; 可用于统计打点，可使用第三方统计服务</span><br><span class="line">&lt;link &#x2F;&gt; &lt;script&gt; 可使用 CDN , CDN 一般都是外域</span><br><span class="line">&lt;script&gt; 可实现 JSONP</span><br></pre></td></tr></table></figure>

<p><strong>跨域</strong></p>
<ul>
<li>所有的跨域，都必须经过 server 端允许和配合</li>
<li>未经 server 端允许就实现跨域，说明浏览器有漏洞，危险信号</li>
</ul>
</li>
</ul>
<ul>
<li><p>JSONP</p>
<ul>
<li>访问知乎或者虎扑，服务端一定返回同一个 html 文件吗？</li>
<li>服务器可以任意动态拼接数据返回，只要符合 html 格式要求</li>
<li>同理访问 script 的一个 js 文件，不一定返回的是一个静态的 js 文件，而是服务端可以任意拼接符合 js 不报错即可</li>
</ul>
<p><strong>JSONP 原理</strong></p>
<p>**1.**通过 script 可绕过跨域限制</p>
<p>**2.**服务器可以任意动态拼接数据返回</p>
<p>**3.**所以，script 标签就可以获得跨域的数据，只要服务端愿意返回</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- JSONP 代码演示 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.abc = <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(data)</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://localhost:8002/jsonp.js?username=xxx&amp;callback=abc&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- jsonp.js --&gt;</span></span><br><span class="line">abc(</span><br><span class="line">    &#123; name: &#x27;xxx&#x27; &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>CORS（服务器端支持）</p>
<p><strong>CORS - 服务器设置 http header</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第二个参数填写允许跨域的域名称，不建议直接写 &quot;*&quot;</span></span><br><span class="line">response.setHeader(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="string">&quot;http://localhost:8011&quot;</span>);</span><br><span class="line"><span class="comment">// 该字段表明服务端支持的请求方法</span></span><br><span class="line">response.setHeader(<span class="string">&quot;Access-Control-Allow-Methods&quot;</span>, <span class="string">&quot;PUT,POST,GET,DELETE,OPTIONS&quot;</span>);</span><br><span class="line"><span class="comment">// 实际请求将携带的自定义请求首部字段</span></span><br><span class="line">response.setHeader(<span class="string">&quot;Access-Control-Allow-Headers&quot;</span>, <span class="string">&quot;X-Requested-With&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收跨域的 cookie</span></span><br><span class="line">response.setHeader(<span class="string">&quot;Access-Control-Allow-Credentials&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="手写一个简易的-Ajax"><a href="#手写一个简易的-Ajax" class="headerlink" title="手写一个简易的 Ajax"></a>手写一个简易的 Ajax</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 结合 Promise 使用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">url, type, success</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">        xhr.open(type, url, <span class="literal">true</span>)</span><br><span class="line">        xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (xhr.status === <span class="number">200</span>) &#123;</span><br><span class="line">                    resolve(<span class="built_in">JSON</span>.parse(xhr.responseText))</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (xhr.status === <span class="number">404</span>) &#123;</span><br><span class="line">                    reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;404 not found&quot;</span>))</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        xhr.send(<span class="literal">null</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> url = <span class="string">&quot;./test.json&quot;</span></span><br><span class="line">ajax(url, <span class="string">&quot;GET&quot;</span>)</span><br><span class="line">    .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res)</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<h1 id="实际项目中-Ajax-的常用插件"><a href="#实际项目中-Ajax-的常用插件" class="headerlink" title="实际项目中 Ajax 的常用插件"></a>实际项目中 Ajax 的常用插件</h1><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch">使用 Fetch - Web API 接口参考 | MDN (mozilla.org)</a></p>
<p><a href="http://www.axios-js.com/zh-cn/docs/">axios中文文档|axios中文网 | axios (axios-js.com)</a></p>
]]></content>
      <categories>
        <category>前端面试题</category>
      </categories>
      <tags>
        <tag>JS基础</tag>
        <tag>知识点总结</tag>
        <tag>JS-Web-API-Ajax</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面试题总结-JS之异步进阶2</title>
    <url>/2020/12/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93-JS%E4%B9%8B%E5%BC%82%E6%AD%A5%E8%BF%9B%E9%98%B62/</url>
    <content><![CDATA[<h1 id="宏任务-macroTask-和微任务-microTask"><a href="#宏任务-macroTask-和微任务-microTask" class="headerlink" title="宏任务 macroTask 和微任务 microTask"></a>宏任务 macroTask 和微任务 microTask</h1><a id="more"></a>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不同类型的异步执行顺序不同</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">100</span>)</span><br><span class="line"><span class="comment">// 宏任务</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">200</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 微任务</span></span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">300</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">400</span>)</span><br><span class="line"><span class="comment">// 100 -&gt; 400 -&gt; 300 -&gt; 200</span></span><br></pre></td></tr></table></figure>

<ul>
<li>宏任务：setTimeout、setInterval、Ajax、DOM 事件</li>
<li>微任务：Promise、async / await</li>
<li>微任务执行时机比宏任务要早</li>
</ul>
<h1 id="event-loop-和-DOM-渲染"><a href="#event-loop-和-DOM-渲染" class="headerlink" title="event loop 和 DOM 渲染"></a>event loop 和 DOM 渲染</h1><ul>
<li>JS 是单线程的，而且和 DOM 渲染共用一个线程</li>
<li>JS 执行的时候，得留一些时机供 DOM 渲染</li>
</ul>
<p><strong>再次回顾 event loop 的过程</strong></p>
<ul>
<li>每一次 call stack 结束（每次轮询结束），同步任务执行完毕，都会触发 DOM 渲染（不一定非得渲染，就是给一次 DOM 渲染的机会！）</li>
<li>然后再触发下一次 Event Loop</li>
</ul>
<p>触发 Event Loop 机制，如果 Callback Queue 里面执行完毕，也就是 call stack 再次空闲，又会尝试触发 DOM 渲染，然后再触发 Event Loop 机制，以此循环下去。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> $p1 = $(<span class="string">&#x27;&lt;p&gt;一段文字&lt;/p&gt;&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> $p2 = $(<span class="string">&#x27;&lt;p&gt;一段文字&lt;/p&gt;&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> $p3 = $(<span class="string">&#x27;&lt;p&gt;一段文字&lt;/p&gt;&#x27;</span>)</span><br><span class="line">$(<span class="string">&quot;#container&quot;</span>).append($p1).append($p2).append($p3)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;length&#x27;</span>,  $(<span class="string">&#x27;#container&#x27;</span>).children().length )</span><br><span class="line">alert(<span class="string">&#x27;本次 call stack 结束，DOM 结构已更新，但尚未触发渲染&#x27;</span>)</span><br><span class="line"><span class="comment">// （alert 会阻断 js 执行，也会阻断 DOM 渲染，便于查看效果，因此只有当关闭 alert 对话框的时候才会渲染出标签）</span></span><br><span class="line"><span class="comment">// 到此，即本次 call stack 结束后（同步任务都执行完了），浏览器会自动触发渲染，不用代码干预</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 另外，按照 event loop 触发 DOM 渲染时机，setTimeout 时 alert ，就能看到 DOM 渲染后的结果了</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">&#x27;setTimeout 是在下一次 Call Stack ，就能看到 DOM 渲染出来的结果了&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="宏任务与微任务的区别"><a href="#宏任务与微任务的区别" class="headerlink" title="宏任务与微任务的区别"></a>宏任务与微任务的区别</h1><ul>
<li><p>宏任务：在 DOM 渲染后触发，如 setTimeout</p>
</li>
<li><p>微任务：DOM 渲染前触发，如 Promise</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修改 DOM</span></span><br><span class="line"><span class="keyword">const</span> $p1 = $(<span class="string">&#x27;&lt;p&gt;一段文字&lt;/p&gt;&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> $p2 = $(<span class="string">&#x27;&lt;p&gt;一段文字&lt;/p&gt;&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> $p3 = $(<span class="string">&#x27;&lt;p&gt;一段文字&lt;/p&gt;&#x27;</span>)</span><br><span class="line">$(<span class="string">&quot;#container&quot;</span>).append($p1).append($p2).append($p3)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 微任务：渲染之前执行（DOM 结构已更新）</span></span><br><span class="line"><span class="comment">// Promise.resolve().then(() =&gt; &#123;</span></span><br><span class="line"><span class="comment">//     const length = $(&#x27;#container&#x27;).children().length</span></span><br><span class="line"><span class="comment">//     alert(`micro task $&#123;length&#125;`) // 3,DOM 没有渲染出来</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 宏任务：渲染之后执行（DOM 结构已更新）</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> length = $(<span class="string">&#x27;#container&#x27;</span>).children().length</span><br><span class="line">    alert(<span class="string">`macro task <span class="subst">$&#123;length&#125;</span>`</span>) <span class="comment">// 3,DOM 已经渲染完毕</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>再深入思考一下：为何两者会有以上区别，一个在渲染前，一个在渲染后？</p>
<ul>
<li>微任务：ES 语法标准之内，JS 引擎来统一处理。即，不用浏览器有任何干预，即可一次性处理完，更快更及时。</li>
<li>宏任务：ES 语法没有，JS 引擎不处理，浏览器（或 nodejs）干预处理。</li>
</ul>
<h1 id="从-event-loop-解释，为何微任务执行更早"><a href="#从-event-loop-解释，为何微任务执行更早" class="headerlink" title="从 event loop 解释，为何微任务执行更早"></a>从 event loop 解释，为何微任务执行更早</h1><img src="image-20201203094801835.png" alt="image-20201203094801835" style="zoom: 25%;" />

<p>当执行 Promise 或 async/await 这种微任务的时候，会等待时机将它放在 micro task queue （与宏任务队列 Callba queue 是分开的）里面，而且不会经过 Web APIs ，因为 Promise 是 ES6 规范，不是 W3C 规范。</p>
<p>产生这种区别的原因是：</p>
<ul>
<li>微任务是 ES6 语法规定的</li>
<li>宏任务是由浏览器规定的</li>
</ul>
<p>因此在执行的时候分成了四步来完成：</p>
<img src="image-20201203095401879.png" alt="image-20201203095401879" style="zoom:25%;" />

<h1 id="微任务和宏任务-总结"><a href="#微任务和宏任务-总结" class="headerlink" title="微任务和宏任务-总结"></a>微任务和宏任务-总结</h1><ul>
<li>宏任务有哪些？微任务有哪些？为什么微任务触发时机更早</li>
<li>微任务、宏任务和 DOM 渲染的关系</li>
<li>微任务、宏任务和 DOM 渲染，在 event loop 的过程</li>
</ul>
<h1 id="考题"><a href="#考题" class="headerlink" title="考题"></a>考题</h1><p><strong>描述 event loop 机制（可画图）</strong></p>
<ul>
<li>回顾 event loop 的过程</li>
<li>和 DOM 渲染的关系</li>
<li>微任务和宏任务在 event loop 过程中的不同处理</li>
</ul>
<p>后两点可以先放一放，先把第一点讲清楚后，如果进阶问，再讲这块，否则一气讲完会很乱</p>
<p><strong>什么事宏任务和微任务，两者区别</strong></p>
<ul>
<li>宏任务：setTimeout，setInterval、Ajax、DOM 事件</li>
<li>微任务：Promise、async/await</li>
<li>微任务执行时机比宏任务要早（再细就是微任务在 DOM 渲染前触发，宏任务在 DOM 渲染后触发）</li>
</ul>
<p><strong>Promise 的三种状态，如何变化</strong></p>
<ul>
<li>pending、resolved、rejected</li>
<li>pending -&gt; resolved 或 pending -&gt; rejected</li>
<li>变化不可逆</li>
</ul>
<p><strong>场景题 - promise then 和 catch 的连接</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一题</span></span><br><span class="line"><span class="built_in">Promise</span>.resolve()</span><br><span class="line">    .then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二题</span></span><br><span class="line"><span class="built_in">Promise</span>.resolve()</span><br><span class="line">    .then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;error1&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三题</span></span><br><span class="line"><span class="built_in">Promise</span>.resolve()</span><br><span class="line">    .then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;error1&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：13，123，12</span></span><br></pre></td></tr></table></figure>

<p><strong>场景题 - async / await 语法</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line">!(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> a = fn() <span class="comment">// ??</span></span><br><span class="line">    <span class="keyword">const</span> b = <span class="keyword">await</span> fn() <span class="comment">// ??</span></span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">    <span class="built_in">console</span>.log(b)</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="comment">// a 返回 promise 对象，b 返回 100</span></span><br><span class="line"></span><br><span class="line">!(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;start&quot;</span>)</span><br><span class="line">    <span class="keyword">const</span> a = <span class="keyword">await</span> <span class="number">100</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;a&quot;</span>, a)</span><br><span class="line">    <span class="keyword">const</span> b = <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="number">200</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;b&quot;</span>, b)</span><br><span class="line">    <span class="keyword">const</span> c = <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="number">300</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;c&quot;</span>, c)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">&#125;)() <span class="comment">// 执行完毕后，打印哪些内容？</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// start -&gt; a 100 -&gt; b 200 -&gt; 报错</span></span><br></pre></td></tr></table></figure>

<p><strong>场景题 - Promise 和 setTimeout 的顺序</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">100</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">200</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">300</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">400</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 100 -&gt; 400 -&gt; 300 -&gt; 200</span></span><br></pre></td></tr></table></figure>

<p><strong>场景题 - 外加 async / await 的顺序问题</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;async1 start&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> async2()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;async1 end&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;async2&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;script start&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;setTimeout&quot;</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">async1()</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;promise1&quot;</span>)</span><br><span class="line">    resolve()</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;promise2&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;script end&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// script start -&gt; async1 start -&gt; async2 -&gt; promise1 -&gt; script end -&gt; async1 end -&gt; promise2 -&gt; setTimeout</span></span><br></pre></td></tr></table></figure>

<p><em>注：new Promise 时，传入的函数会立马被执行</em></p>
]]></content>
      <categories>
        <category>前端面试题</category>
      </categories>
      <tags>
        <tag>JS基础</tag>
        <tag>知识点总结</tag>
        <tag>异步进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面试题总结-JS之异步进阶1</title>
    <url>/2020/12/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93-JS%E4%B9%8B%E5%BC%82%E6%AD%A5%E8%BF%9B%E9%98%B61/</url>
    <content><![CDATA[<p>想进互联网大厂，就会有更多的异步问题…</p>
<p>在这一块，一线大厂面试官经常会玩着花样的去考，所以务必要会！</p>
<h1 id="event-loop-（事件循环-事件轮询）"><a href="#event-loop-（事件循环-事件轮询）" class="headerlink" title="event loop （事件循环 / 事件轮询）"></a>event loop （事件循环 / 事件轮询）</h1><a id="more"></a>

<p>这一块非常重要！</p>
<p>首先</p>
<ul>
<li>JS 是单线程运行的</li>
<li>异步要基于回调来实现</li>
<li>event loop 就是异步回调的实现原理</li>
</ul>
<p>这一块需要了解一下 JS 是如何执行的</p>
<ul>
<li>JS 代码是从前到后，一行一行执行的</li>
<li>如果某一行执行错误，则停止下面代码的执行</li>
<li>先把同步代码执行完，再执行异步</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先看一个示例</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;Hi&quot;</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> <span class="title">cb1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;cb1&quot;</span>) <span class="comment">// cb 即为 callback</span></span><br><span class="line">&#125;, <span class="number">5000</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;Bye&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><em>注： 学习 event loop 这一块不要扣细节，不要扩大范围，核心就是 event loop 的过程</em></p>
<p><strong>执行第一行代码</strong></p>
<img src="image-20201202090054370.png" alt="image-20201202090054370" style="zoom: 25%;" />



<p><strong>执行第二行代码</strong></p>
<p>setTimeout 是一个函数，函数第一个参数是一个 function，第二个参数是 5s，此时浏览器 console 行不会打印任何东西，暂时执行不到 console.log(‘cb1’) , 推入调用栈并执行 setTimeout 函数时，由于 setTimeout 函数是浏览器定义的（也就是在 Web APIs 这块定义的），它不是 es6 的一个内容，所以我们执行这个函数的时候，这个函数的背后其实是把它的第一个参数 cb1 给它放到一个定时器里面，定时器的定时是 5s，5s 之后把 cb1 放入 Callback Queue 里面，这样 setTimeout 这三行代码就执行结束了，然后再次将调用栈清空，但是此时定时器还在，不会清空。简单来说，setTimeout 执行的产出就是将 cb1 放入到一个定时器里面。</p>
<img src="image-20201202092527861.png" alt="image-20201202092527861" style="zoom: 25%;" />



<p><strong>执行第三行代码</strong></p>
<img src="image-20201202093122044.png" alt="image-20201202093122044" style="zoom: 25%;" />

<p>执行完第三行后，此时这个定时器还会在，因为从第一行执行到最后一行的时间极短。</p>
<p><strong>整个主线的同步代码（两个 log，一个 setTimeout）全部执行完后，此时没有任何代码将要推到 Call Stack 中执行，也就是 Call Stack 空了，这个时候会启动 Event Loop 机制（浏览器内核启动），这个机制会一遍一遍的做循环，每次循环回到 Callback Queue （也就是异步函数回调）里面去找还有没有函数，如果有函数就拿过来推入到 Call Stack 调用栈里面去执行。</strong></p>
<p>1、Callback Queue 为空的</p>
<img src="image-20201202094217599.png" alt="image-20201202094217599" style="zoom: 25%;" />

<p>2、5s 后，定时器把 cb1 推到 Callback Queue 里面</p>
<img src="image-20201202094241074.png" alt="image-20201202094241074" style="zoom: 25%;" />

<p>3、 Event Loop 触发的时候会发现 cb1 的函数，就立马将这个函数推到 Call Stack  里面，并且将 Callback Queue 清空</p>
<img src="image-20201202094304243.png" alt="image-20201202094304243" style="zoom: 25%;" />

<p>4、 有了函数放到 Call Stack 里面，就会立马触发这个函数的执行，由于这个函数有一个函数体 console.log(‘cb1’) ，所以定位到 setTimeout 里面的 console.log(‘cb1’) 行，然后将这行推入到调用栈里面，调用栈执行，在浏览器 console 区打印 cb1</p>
<img src="image-20201202094856278.png" alt="image-20201202094856278" style="zoom: 25%;" />

<p>当打印语句执行完后，就会在调用栈里面将其清空</p>
<img src="image-20201202094950795.png" alt="image-20201202094950795" style="zoom: 25%;" />

<p>当打印语句执行完毕后，也就代表着 setTimeout 执行完毕，所以也将 cb1 函数从调用栈中清除</p>
<img src="image-20201202095104446.png" alt="image-20201202095104446" style="zoom:25%;" />

<h2 id="总结-Event-Loop-过程-1"><a href="#总结-Event-Loop-过程-1" class="headerlink" title="总结 Event Loop 过程 1"></a>总结 Event Loop 过程 1</h2><ul>
<li>同步代码，一行一行放在 Call Stack 中执行</li>
<li>遇到异步，会先 “记录” 下，等待时机（定时，网络请求等，时机一到就会放入到 Callback Queue 里面）</li>
</ul>
<h2 id="总结-Event-Loop-过程-2"><a href="#总结-Event-Loop-过程-2" class="headerlink" title="总结 Event Loop 过程 2"></a>总结 Event Loop 过程 2</h2><ul>
<li>如 Call Stack 为空（即同步代码执行完毕），Event Loop 开始工作</li>
<li>轮询查找 Callback Queue ，如有则移动到 Call Stack 执行</li>
<li>然后继续轮询查找（如setInterval永动机一样）</li>
</ul>
<h2 id="DOM-事件与-Event-Loop"><a href="#DOM-事件与-Event-Loop" class="headerlink" title="DOM 事件与 Event Loop"></a>DOM 事件与 Event Loop</h2><p>DOM 事件也使用回调，基于 Event Loop，触发时机与定时器不同，是浏览器控制的，监听用户的点击事件，但 DOM 事件不是异步</p>
<img src="image-20201202101219328.png" alt="image-20201202101219328" style="zoom: 33%;" />

<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><ul>
<li>三种状态</li>
<li>状态的表现和变化</li>
<li>then 和 catch 对状态的影响</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过 Promise 实现加载一张图片</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadImg</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// pending...</span></span><br><span class="line">    <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> img = <span class="built_in">document</span>.createElement(<span class="string">&quot;img&quot;</span>)</span><br><span class="line">        img.onload = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            resolve(img)  <span class="comment">// resolved</span></span><br><span class="line">        &#125;</span><br><span class="line">        img.onerror = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> err = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`图片加载失败！<span class="subst">$&#123;src&#125;</span>`</span>)</span><br><span class="line">            reject(err)  <span class="comment">// rejected</span></span><br><span class="line">        &#125;</span><br><span class="line">        img.src = src</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> urll = <span class="string">&quot;./1.jpg&quot;</span></span><br><span class="line"><span class="comment">// 通过链式调用避免 Callback hell</span></span><br><span class="line">loadImg(urll)</span><br><span class="line">    .then(<span class="function">(<span class="params">img1</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(img1.width)</span><br><span class="line">        <span class="comment">// 返回一个普通对象</span></span><br><span class="line">        <span class="keyword">return</span> img1</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function">(<span class="params">img1</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(img1.height)</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(err)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<h2 id="三种状态"><a href="#三种状态" class="headerlink" title="三种状态"></a>三种状态</h2><ul>
<li>pending（在过程中，还没结果）、resolved（已经成功解决了，<strong>又称Fulfilled</strong>）、rejected（已经失败了）</li>
</ul>
<h2 id="状态的变化"><a href="#状态的变化" class="headerlink" title="状态的变化"></a>状态的变化</h2><ul>
<li>pending -&gt; resolved     或者     pending -&gt; rejected</li>
<li>这种变化是不可逆的</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代码演示</span></span><br><span class="line"><span class="comment">// pending</span></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; &#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;p1&quot;</span>, p1)  <span class="comment">// promise 为 pending 状态</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// resolve/fulfilled</span></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 模拟一个异步</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        resolve()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;p2&quot;</span>, p2) <span class="comment">// 点开后 promise 为 resolve/fulfilled 状态</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;p2-setTimeout&quot;</span>, p2)) <span class="comment">// resolve/fulfilled 状态</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// rejected</span></span><br><span class="line"><span class="keyword">const</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 模拟一个异步</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        reject()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;p3-setTimeout&quot;</span>, p3)) <span class="comment">// rejected状态</span></span><br></pre></td></tr></table></figure>

<h2 id="状态的表现"><a href="#状态的表现" class="headerlink" title="状态的表现"></a>状态的表现</h2><ul>
<li>pending 状态，不会触发 then 和 catch</li>
<li>resolved 状态，会触发后续的 then 回调函数</li>
<li>rejected 状态，会触发后续的 catch 回调函数</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="built_in">Promise</span>.resolve(<span class="number">100</span>) <span class="comment">// resolved</span></span><br><span class="line"><span class="comment">// console.log(&quot;p1&quot;, p1)</span></span><br><span class="line">p1.then(<span class="function">(<span class="params">data1</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;data1&quot;</span>, data1)</span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">err1</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;err1&quot;</span>, err1) <span class="comment">// 不会触发，因为 p1 是 resolved 状态</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="built_in">Promise</span>.reject(<span class="string">&quot;error2&quot;</span>) <span class="comment">// rejected</span></span><br><span class="line"><span class="comment">// console.log(&quot;p2&quot;, p2)</span></span><br><span class="line">p2.then(<span class="function">(<span class="params">data2</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;data2&quot;</span>, data2)</span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">err2</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;err2&quot;</span>, err2)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="then-和-catch-改变状态"><a href="#then-和-catch-改变状态" class="headerlink" title="then 和 catch 改变状态"></a>then 和 catch 改变状态</h2><ul>
<li>then 正常返回 resolved，里面有报错则返回 rejected</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// console.log(&quot;p1&quot;, p1) // resolved 触发后续 then 的回调</span></span><br><span class="line">p1.then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="number">123</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;then error&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// console.log(&quot;p2&quot;, p2) // rejected 触发后续 catch 的回调</span></span><br><span class="line">p2.then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="number">456</span>)).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;err100&quot;</span>, err))</span><br></pre></td></tr></table></figure>

<ul>
<li>catch 正常返回 resolved，里面有报错则返回 rejected</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p3 = <span class="built_in">Promise</span>.reject(<span class="string">&quot;my error1&quot;</span>).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;p3&quot;</span>, p3) <span class="comment">// resolved or fulfilled 注意！ 触发 then 回调</span></span><br><span class="line">p3.then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">100</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p4 = <span class="built_in">Promise</span>.reject(<span class="string">&quot;my error&quot;</span>).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;my error2&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;p4&quot;</span>, p4) <span class="comment">// rejected  触发 catch 回调</span></span><br><span class="line">p4.catch(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">200</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="Promise-catch-连接-then"><a href="#Promise-catch-连接-then" class="headerlink" title="Promise catch 连接 then"></a>Promise catch 连接 then</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一些小题目</span></span><br><span class="line"><span class="comment">// 第一题</span></span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;).catch(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 1 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二题</span></span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;erro1&#x27;</span>)</span><br><span class="line">&#125;).catch(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 1 2 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三题</span></span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;erro1&#x27;</span>)</span><br><span class="line">&#125;).catch(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;).catch(<span class="function">() =&gt;</span> &#123; <span class="comment">// 注意这里是 catch</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 1 2</span></span><br></pre></td></tr></table></figure>

<h2 id="Promise-总结"><a href="#Promise-总结" class="headerlink" title="Promise 总结"></a>Promise 总结</h2><ul>
<li>三种状态，状态的表现和变化</li>
<li>then 和 catch 对状态的影响（重要）</li>
<li>then 和 catch 的链式调用</li>
</ul>
<h1 id="async-await"><a href="#async-await" class="headerlink" title="async / await"></a>async / await</h1><p>async / await 是同步语法，彻底消灭回调函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代码演示</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadImg</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// pending...</span></span><br><span class="line">    <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> img = <span class="built_in">document</span>.createElement(<span class="string">&quot;img&quot;</span>)</span><br><span class="line">        img.onload = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            resolve(img) <span class="comment">// resolved</span></span><br><span class="line">        &#125;</span><br><span class="line">        img.onerror = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> err = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`图片加载失败！<span class="subst">$&#123;src&#125;</span>`</span>)</span><br><span class="line">            reject(err) <span class="comment">// rejected</span></span><br><span class="line">        &#125;</span><br><span class="line">        img.src = src</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> src1 = <span class="string">&quot;./1.jpg&quot;</span></span><br><span class="line"><span class="keyword">const</span> src2 = <span class="string">&quot;./2.jpg&quot;</span></span><br><span class="line"><span class="comment">// 通常在立即执行函数前面加一个 ！ 来避免 ...() 执行的歧义</span></span><br><span class="line">!(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 同步的写法</span></span><br><span class="line">    <span class="comment">// 获取 img1</span></span><br><span class="line">    <span class="keyword">const</span> img1 = <span class="keyword">await</span> loadImg(src1)</span><br><span class="line">    <span class="built_in">console</span>.log(img1.height, img1.width)</span><br><span class="line">    <span class="comment">// 获取 img2</span></span><br><span class="line">    <span class="keyword">const</span> img2 = <span class="keyword">await</span> loadImg(src2)</span><br><span class="line">    <span class="built_in">console</span>.log(img2.height, img2.width)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<h2 id="async-await-和-Promise-的关系"><a href="#async-await-和-Promise-的关系" class="headerlink" title="async / await 和 Promise 的关系"></a>async / await 和 Promise 的关系</h2><ul>
<li>async / await 是消灭异步回调的终极武器</li>
<li>但和 Promise 并不互斥</li>
<li>反而两者相辅相成</li>
</ul>
<p>两者结合，总结来说</p>
<ul>
<li>执行 async 函数，返回的是 Promise 对象</li>
<li>await 相当于 Promise 的 then</li>
<li>try…catch 可捕获异常，代替了 Promise 的 catch</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行 async 函数，返回的是 Promise 对象</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span> <span class="comment">// 相当于 return Promise.resolve(100)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> res1 = fn1() <span class="comment">// 执行 async 函数返回的是一个 Promise 对象</span></span><br><span class="line"><span class="built_in">console</span>.log(res1) <span class="comment">// Promise 对象</span></span><br><span class="line">res1.then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;data&quot;</span>, data) <span class="comment">// 100</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// await 相当于 Promise 的 then</span></span><br><span class="line">!(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> p1 = <span class="built_in">Promise</span>.resolve(<span class="number">300</span>)</span><br><span class="line">    <span class="keyword">const</span> data = <span class="keyword">await</span> p1 <span class="comment">// await 相当于 Promise 的 then</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;data&quot;</span>, data)</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="comment">// await 后面跟的不是一个 Promise 对象</span></span><br><span class="line">!(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> data1 = <span class="keyword">await</span> <span class="number">400</span> <span class="comment">// 相当于封装成 await Promise.resolve(400)</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;data1&quot;</span>, data1)</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="comment">// try...catch 相当于 Promise 的 catch</span></span><br><span class="line">!(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> p4 = <span class="built_in">Promise</span>.reject(<span class="string">&quot;err&quot;</span>) <span class="comment">// rejected 状态</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> res = <span class="keyword">await</span> p4</span><br><span class="line">        <span class="built_in">console</span>.log(res)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(ex)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>



<h1 id="异步的本质"><a href="#异步的本质" class="headerlink" title="异步的本质"></a>异步的本质</h1><ul>
<li><p>async / await 是消灭异步回调的终极武器</p>
</li>
<li><p>JS 还是单线程，还得是有异步，还是得基于 event loop</p>
</li>
<li><p>async / await 只是一个基于 Promise 的语法糖，但这颗糖是真的香！</p>
<p>它让我们可以使用同步的方式写异步代码</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 真题示例1</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;async1 start&quot;</span>) <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">await</span> async2() <span class="comment">// undefined</span></span><br><span class="line">    <span class="comment">// await 后面，都可以看做是 callback 里的内容，即异步</span></span><br><span class="line">    <span class="comment">// 类似，event loop ，setTimeout(cb1)</span></span><br><span class="line">    <span class="comment">// setTimeout(function () &#123; console.log(&#x27;async end) &#125;)</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;async1 end&quot;</span>) <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;async2&quot;</span>) <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;script start&quot;</span>) <span class="comment">// 1</span></span><br><span class="line">async1()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;script end&quot;</span>) <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 真题示例2</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;async1 start&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> async2()</span><br><span class="line">    <span class="comment">// 下面三行都是异步回调 callback 的内容</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;async1 end&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> async3()</span><br><span class="line">    <span class="comment">// 下面一行是异步回调的内容</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;async1 end 2&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;async2&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;async3&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;script start&quot;</span>)</span><br><span class="line">async1()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;script end&quot;</span>)</span><br><span class="line"><span class="comment">// script start -&gt; async1 start -&gt; async2 -&gt; script end -&gt; async1 end -&gt; async3 -&gt; async1 end 2</span></span><br></pre></td></tr></table></figure>

<p><em>注：首先定义函数不执行不用管，其次异步函数执行要立马执行函数体，await 下面的代码都是异步内容，当同步代码执行完毕，参考 event loop 的机制，启动异步代码的执行</em></p>
<p><strong>异步的本质是，JS 是单线程的，JS 的异步需要回调，哪怕我们有 async / await 这种比较高级的语法，是 Promise 的语法糖。异步要基于 event loop 去实现。</strong></p>
<h1 id="for…of-（重要）"><a href="#for…of-（重要）" class="headerlink" title="for…of  （重要）"></a>for…of  （重要）</h1><ul>
<li>类似于 for…in (以及 forEach、for ) 是常规的同步遍历</li>
<li>for…of 常用于异步的遍历</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">muti</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            resolve(num * num)</span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="comment">// // forEach 为同步的遍历，不会等待，会在一瞬间执行完成</span></span><br><span class="line"><span class="comment">// // 所以同时出现 1   4   9</span></span><br><span class="line"><span class="comment">// nums.forEach(async (i) =&gt; &#123;</span></span><br><span class="line"><span class="comment">//     const res = await muti(i)</span></span><br><span class="line"><span class="comment">//     console.log(res)</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 想要做出排队一样的效果就需要用到 for...of</span></span><br><span class="line">!(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> nums) &#123;</span><br><span class="line">        <span class="keyword">const</span> res = <span class="keyword">await</span> muti(i)</span><br><span class="line">        <span class="built_in">console</span>.log(res)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端面试题</category>
      </categories>
      <tags>
        <tag>JS基础</tag>
        <tag>知识点总结</tag>
        <tag>异步进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面试题总结-JS基础之作用域和闭包</title>
    <url>/2020/11/30/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93-JS%E5%9F%BA%E7%A1%80%E4%B9%8B%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[<p>三座大山之二，不会闭包，基本不会通过！</p>
<h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><ul>
<li>全局作用域</li>
<li>函数作用域</li>
<li>块级作用域（ES6新增）</li>
</ul>
<a id="more"></a>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ES6 块级作用域</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(x)  <span class="comment">// 会报错</span></span><br></pre></td></tr></table></figure>



<h2 id="自由变量"><a href="#自由变量" class="headerlink" title="自由变量"></a>自由变量</h2><ul>
<li>一个变量没有被当前作用域定义，但被使用了</li>
<li>向上级作用域，一层一层依次寻找，直到找到为止</li>
<li>如果到全局作用域都没找到，则报错 xx is not defined</li>
</ul>
<img src="1606279652721.png" alt="1606279652721" style="zoom: 80%;" />

<p>如上图，a、a1、a2 都是自由变量，a3则是在当前函数作用域下定义过</p>
<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>其实是作用域应用的特殊情况，有两种表现:</p>
<ul>
<li>函数作为参数被传递</li>
<li>函数作为返回值被返回</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数作为返回值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> a = <span class="number">100</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 此处的 a 是一个自由变量，向上级作用域寻找</span></span><br><span class="line">        <span class="built_in">console</span>.log(a)  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> fn = create()</span><br><span class="line"><span class="keyword">const</span> a = <span class="number">200</span></span><br><span class="line">fn()  <span class="comment">// 100</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数作为参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> a = <span class="number">200</span></span><br><span class="line">    fn()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> a = <span class="number">100</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// a 是自由变量，上级作用域为全局作用域</span></span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;</span><br><span class="line">print(fn)  <span class="comment">// 100</span></span><br></pre></td></tr></table></figure>

<p><strong>总结：所有的自由变量的查找，是在函数定义的地方向上级作用域查找，不是在执行的地方！！！</strong></p>
<h1 id="this"><a href="#this" class="headerlink" title="this"></a>this</h1><ul>
<li>作为普通函数被调用</li>
<li>使用 call、apply、bind 调用</li>
<li>作为对象方法被调用</li>
<li>在 class 方法中调用</li>
<li>在箭头函数中调用</li>
</ul>
<p><strong>切记，this 在上诉场景中取什么样的值，是在函数执行的时候确认的，不是在定义的时候确认的</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">fn1()  <span class="comment">// window</span></span><br><span class="line"></span><br><span class="line">fn1.call(&#123; <span class="attr">x</span>: <span class="number">100</span> &#125;) <span class="comment">// &#123; x: 100 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fn2 = fn1.bind(&#123; <span class="attr">x</span>: <span class="number">200</span> &#125;)  <span class="comment">// bind返回一个新的函数</span></span><br><span class="line">fn2()  <span class="comment">// &#123; x: 200 &#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> zs = &#123;</span><br><span class="line">    name: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">    <span class="function"><span class="title">sayHi</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// this 即当前对象 zs</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">wait</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">// this === window</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">        &#125;, <span class="number">100</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> zs = &#123;</span><br><span class="line">    name: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">    <span class="function"><span class="title">sayHi</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// this 即当前对象 zs</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">waitAgain</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// this 即当前对象 zs</span></span><br><span class="line">            <span class="comment">// 箭头函数里面的 this 取值是取上级作用域的 this 值</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name</span><br><span class="line">        <span class="built_in">this</span>.age = <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">sayHi</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> zs = <span class="keyword">new</span> People(<span class="string">&quot;张三&quot;</span>)</span><br><span class="line">zs.sayHi()   <span class="comment">// zs 对象</span></span><br></pre></td></tr></table></figure>



<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="this-不同应用场景如何取值"><a href="#this-不同应用场景如何取值" class="headerlink" title="this  不同应用场景如何取值"></a>this  不同应用场景如何取值</h2><ul>
<li>作为普通函数调用（包括立即执行函数），this 指向 window</li>
<li>使用 call、apply、bind 调用，传入什么 this 就指向的是什么</li>
<li>在对象方法中调用，如果有 settimeout 则 this 指向 window ，若无 settimeout ，则指向当前对象本身</li>
<li>在箭头函数中的 this 取上级作用域的 this 的值</li>
<li>在 class 方法中调用 this ，则指向实例本身</li>
</ul>
<h2 id="手写-bind-函数"><a href="#手写-bind-函数" class="headerlink" title="手写 bind 函数"></a>手写 bind 函数</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一种 通过 call 或 apply 实现</span></span><br><span class="line"><span class="comment">// 通过在构造函数原型对象上增加一个 myBind 来模拟 bind</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 将参数拆解为数组</span></span><br><span class="line">    <span class="comment">// const args = Array.prototype.slice.call(arguments)</span></span><br><span class="line">    <span class="keyword">const</span> args = [...arguments]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 this 并将数组第一项 this 挖出去</span></span><br><span class="line">    <span class="keyword">const</span> t = args.shift()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fn1.myBind(...) 中的 fn1</span></span><br><span class="line">    <span class="comment">// 由于是 fn1 调用的 bind2</span></span><br><span class="line">    <span class="comment">// 所以这里的 this 指向 fn1</span></span><br><span class="line">    <span class="keyword">const</span> self = <span class="built_in">this</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回一个函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> self.apply(t, args)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种 不通过 call、apply 方法实现</span></span><br><span class="line"><span class="comment">// Function.prototype.myBind = function () &#123;</span></span><br><span class="line"><span class="comment">//     const args = [...arguments]</span></span><br><span class="line"><span class="comment">//     const fn = Symbol(&quot;fn&quot;)</span></span><br><span class="line"><span class="comment">//     const bindObj = args.shift()</span></span><br><span class="line"><span class="comment">//     bindObj.fn = this</span></span><br><span class="line"><span class="comment">//     return function () &#123;</span></span><br><span class="line"><span class="comment">//         const result = bindObj.fn(...args)</span></span><br><span class="line"><span class="comment">//         delete bindObj.fn</span></span><br><span class="line"><span class="comment">//         return result</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;this&#x27;</span>, <span class="built_in">this</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(a, b, c)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;this is fn1&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fn2 = fn1.myBind(&#123; <span class="attr">x</span>: <span class="number">100</span> &#125;, <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>)</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">相当于返回了一个函数</span></span><br><span class="line"><span class="comment">const fn2 = function () &#123;</span></span><br><span class="line"><span class="comment">    return fn1.apply(&#123; x: 100 &#125;, [10, 20, 30])</span></span><br><span class="line"><span class="comment">&#125; </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> res = fn2()</span><br><span class="line"><span class="built_in">console</span>.log(res)</span><br></pre></td></tr></table></figure>



<h2 id="手写-call-函数"><a href="#手写-call-函数" class="headerlink" title="手写 call 函数"></a>手写 call 函数</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这一段是无参数判断逻辑，并通过 apply 实现</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> args = [...arguments]</span><br><span class="line">    <span class="keyword">const</span> t = args.shift()</span><br><span class="line">    <span class="keyword">const</span> self = <span class="built_in">this</span></span><br><span class="line">    <span class="keyword">const</span> result = self.apply(t, args)</span><br><span class="line">    <span class="built_in">console</span>.log(self)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第二种实现方式 不通过 apply 实现</span></span><br><span class="line"><span class="comment">// Function.prototype.myCall = function () &#123;</span></span><br><span class="line"><span class="comment">//     const args = [...arguments]</span></span><br><span class="line"><span class="comment">//     const self = args.shift()</span></span><br><span class="line"><span class="comment">//     const fn = Symbol(&quot;fn&quot;)</span></span><br><span class="line"><span class="comment">//     self.fn = this</span></span><br><span class="line"><span class="comment">//     const result = self.fn(...args)</span></span><br><span class="line"><span class="comment">//     delete self.fn</span></span><br><span class="line"><span class="comment">//     return result</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;this&quot;</span>, <span class="built_in">this</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(a, b, c)</span><br><span class="line">&#125;</span><br><span class="line">a.myCall(&#123; <span class="attr">a</span>: <span class="number">100</span> &#125;, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这一段是实现参数判断逻辑</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 判断传入的第一个参数是否为一个对象且不能为 null</span></span><br><span class="line">    <span class="comment">// 如果不是则 this 为 window</span></span><br><span class="line">    <span class="comment">// const flag = arguments.length &gt;= 2 &amp;&amp; typeof arguments[0] === &#x27;object&#x27; &amp;&amp; arguments[0] !== &#x27;null&#x27;</span></span><br><span class="line">    <span class="comment">// 上下两种逻辑均可</span></span><br><span class="line">    <span class="keyword">const</span> flag = <span class="built_in">arguments</span>.length &gt;= <span class="number">2</span> &amp;&amp; <span class="built_in">arguments</span>[<span class="number">0</span>] <span class="keyword">instanceof</span> <span class="built_in">Object</span></span><br><span class="line">    <span class="keyword">const</span> args = [...arguments]</span><br><span class="line">    <span class="keyword">let</span> t</span><br><span class="line">    <span class="comment">// 如果有绑定的对象则将这个对象从数组中挖出来</span></span><br><span class="line">    <span class="keyword">if</span> (flag) t = args.shift()</span><br><span class="line">    <span class="keyword">const</span> self = <span class="built_in">this</span></span><br><span class="line">    <span class="keyword">const</span> result = self.apply(t, args)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;this&quot;</span>, <span class="built_in">this</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(a, b, c)</span><br><span class="line">&#125;</span><br><span class="line">a.myCall(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>



<h2 id="手写-apply-函数"><a href="#手写-apply-函数" class="headerlink" title="手写 apply 函数"></a>手写 apply 函数</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一种实现方式 通过 call 实现</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.myApply = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> that = <span class="built_in">this</span></span><br><span class="line">    <span class="keyword">const</span> args = [...arguments]</span><br><span class="line">    <span class="keyword">const</span> self = args.shift()</span><br><span class="line">    <span class="comment">// arguments 里面是一个对象 + 数组</span></span><br><span class="line">    <span class="comment">// 通过扩展运算符,并取出第一个对象后</span></span><br><span class="line">    <span class="comment">// 此时里面的 index 为 0 的数据是一个数组，所以需要 args[0]</span></span><br><span class="line">    <span class="keyword">const</span> result = that.call(self, ...args[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第二种实现方式 不通过 call 实现</span></span><br><span class="line"><span class="comment">// Function.prototype.myApply = function (thisArg, args) &#123;</span></span><br><span class="line"><span class="comment">//     const fn = Symbol(&#x27;fn&#x27;)        // 声明一个独有的Symbol属性, 防止fn覆盖已有属性</span></span><br><span class="line"><span class="comment">//     thisArg = thisArg || window    // 若没有传入this, 默认绑定window对象</span></span><br><span class="line"><span class="comment">//     thisArg.fn = this              // this指向调用call的对象,即我们要改变this指向的函数</span></span><br><span class="line"><span class="comment">//     const result = thisArg.fn(...args)  // 执行当前函数</span></span><br><span class="line"><span class="comment">//     delete thisArg.fn              // 删除我们声明的fn属性</span></span><br><span class="line"><span class="comment">//     return result                  // 返回函数执行结果</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(a, b)</span><br><span class="line">&#125;</span><br><span class="line">foo.myApply(&#123; <span class="attr">x</span>: <span class="number">300</span> &#125;, [<span class="number">1</span>, <span class="number">2</span>])</span><br></pre></td></tr></table></figure>

<p><strong><em>注：Symbol 生成一个全局唯一的值</em></strong></p>
<h2 id="三兄弟区别"><a href="#三兄弟区别" class="headerlink" title="三兄弟区别"></a>三兄弟区别</h2><ul>
<li>三兄弟接收的第一个参数都是要绑定的 this 指向</li>
<li>apply 的第二个参数是一个参数数组，call 和 bind 的第二个及之后的参数作为函数实参按顺序传入</li>
<li>bind 不会立即调用，其他两个会立即调用</li>
</ul>
<h1 id="实际开发中闭包的应用"><a href="#实际开发中闭包的应用" class="headerlink" title="实际开发中闭包的应用"></a>实际开发中闭包的应用</h1><ul>
<li><p>隐藏数据</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 闭包隐藏数据，只提供 API</span></span><br><span class="line"><span class="comment">// 做一个简单的 cache 工具</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createCache</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> data = &#123;&#125; <span class="comment">// 闭包中的数据，被隐藏，不被外界访问</span></span><br><span class="line">    <span class="comment">// 闭包的一种方式，返回一个函数</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        set: <span class="function"><span class="keyword">function</span> (<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">            data[key] = value</span><br><span class="line">        &#125;,</span><br><span class="line">        get: <span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> data[key]</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果我们不通过 set、get 无法修改 data 的值</span></span><br><span class="line"><span class="comment">// 因为 data 是在 createCache 作用域里面的，不会被外界所访问</span></span><br><span class="line"><span class="keyword">const</span> c = createCache()</span><br><span class="line">c.set(<span class="string">&quot;a&quot;</span>, <span class="number">100</span>)</span><br><span class="line"><span class="built_in">console</span>.log(c.get(<span class="string">&quot;a&quot;</span>))</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 点击 a 标签弹出对应的标签序号</span></span><br><span class="line"><span class="keyword">let</span> a</span><br><span class="line"><span class="comment">// let i 是定义了一个 for 里面的块级作用域</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    a = <span class="built_in">document</span>.createElement(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">    a.innerHTML = i + <span class="string">&quot;&lt;br&gt;&quot;</span></span><br><span class="line">    a.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">        e.preventDefault()</span><br><span class="line">        alert(i)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者也可使用立即执行函数来实现。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>前端面试题</category>
      </categories>
      <tags>
        <tag>JS基础</tag>
        <tag>知识点总结</tag>
        <tag>作用域和闭包</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面试题总结-JS基础之单线程和异步</title>
    <url>/2020/12/01/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93-JS%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%8D%95%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%BC%82%E6%AD%A5/</url>
    <content><![CDATA[<p>三座大山之三，必考！</p>
<h1 id="单线程和异步"><a href="#单线程和异步" class="headerlink" title="单线程和异步"></a>单线程和异步</h1><ul>
<li>JS 是单线程语言，只能同时做一件事</li>
<li>浏览器和 nodejs 已经支持 JS启动进程，如 Web Worker</li>
<li>JS 和 DOM 渲染共用一个线程，因为 JS 可以修改 DOM 结构</li>
</ul>
<p>因此</p>
<a id="more"></a>

<ul>
<li>遇到等待（网络请求、定时任务）不能卡住</li>
<li>需要异步（解决单线程等待的这种问题）</li>
<li>异步是基于 callback 函数形式</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 异步 通过 callback 函数，这里是 () =&gt; &#123; console.log(200) &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">100</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">200</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">300</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">100</span>)</span><br><span class="line">alert(<span class="number">200</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">300</span>)</span><br></pre></td></tr></table></figure>

<h2 id="异步的应用场景"><a href="#异步的应用场景" class="headerlink" title="异步的应用场景"></a>异步的应用场景</h2><ul>
<li>网络请求，如 Ajax、图片加载</li>
<li>定时任务，如 setTimeout</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ajax</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;start&quot;</span>)</span><br><span class="line">$.get(<span class="string">&quot;./data.json&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;end&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 图片加载</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;start&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> img = <span class="built_in">document</span>.createElement(<span class="string">&quot;img&quot;</span>)</span><br><span class="line">img.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;loaded&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(end)</span><br><span class="line"></span><br><span class="line"><span class="comment">// setTimeout</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">100</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">200</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">300</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// setInterval</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">100</span>)</span><br><span class="line"><span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">200</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">300</span>)</span><br></pre></td></tr></table></figure>

<h1 id="callback-hell"><a href="#callback-hell" class="headerlink" title="callback hell"></a>callback hell</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// callback hell (回调地狱)</span></span><br><span class="line"><span class="comment">// 获取第一份数据</span></span><br><span class="line">$.get(url1, <span class="function">(<span class="params">data1</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data1)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取第二份数据</span></span><br><span class="line">    $.get(url2, <span class="function">(<span class="params">data2</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(data2)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取第三份数据</span></span><br><span class="line">        $.get(url3, <span class="function">(<span class="params">data3</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(data3)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 还可能获取更多的数据</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id=""><a href="#" class="headerlink" title=""></a></h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Promise 主要解决的是 callback hell 的问题</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            url,</span><br><span class="line">            <span class="function"><span class="title">success</span>(<span class="params">data</span>)</span> &#123;</span><br><span class="line">                resolve(data)</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="function"><span class="title">error</span>(<span class="params">err</span>)</span> &#123;</span><br><span class="line">                reject(err)</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> url1 = <span class="string">&quot;./data1.json&quot;</span></span><br><span class="line"><span class="keyword">const</span> url2 = <span class="string">&quot;./data2.json&quot;</span></span><br><span class="line"><span class="keyword">const</span> url3 = <span class="string">&quot;./data3.json&quot;</span></span><br><span class="line">getData(url1)</span><br><span class="line">    .then(<span class="function">(<span class="params">data1</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(data1)</span><br><span class="line">        <span class="keyword">return</span> getData(url2)</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function">(<span class="params">data2</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(data2)</span><br><span class="line">        <span class="keyword">return</span> getData(url3)</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function">(<span class="params">data3</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(data3)</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> <span class="built_in">console</span>.error(err))</span><br></pre></td></tr></table></figure>

<h1 id="同步与异步的区别"><a href="#同步与异步的区别" class="headerlink" title="同步与异步的区别"></a>同步与异步的区别</h1><ul>
<li>异步是基于 JS 是单线程语言</li>
<li>异步不会阻塞代码执行</li>
<li>同步会阻塞代码执行</li>
</ul>
<h1 id="手写-Promise-加载两张图片"><a href="#手写-Promise-加载两张图片" class="headerlink" title="手写 Promise 加载两张图片"></a>手写 Promise 加载两张图片</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadImg</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> img = <span class="built_in">document</span>.createElement(<span class="string">&quot;img&quot;</span>)</span><br><span class="line">        img.onload = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            resolve(img)</span><br><span class="line">        &#125;</span><br><span class="line">        img.onerror = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> err = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`图片加载失败！<span class="subst">$&#123;src&#125;</span>`</span>)</span><br><span class="line">            reject(err)</span><br><span class="line">        &#125;</span><br><span class="line">        img.src = src</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> urll = <span class="string">&quot;./1.jpg&quot;</span></span><br><span class="line"><span class="keyword">const</span> url2 = <span class="string">&quot;./2.jpg&quot;</span></span><br><span class="line">loadImg(urll)</span><br><span class="line">    .then(<span class="function">(<span class="params">img1</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(img1.width)</span><br><span class="line">        <span class="comment">// 返回一个普通对象</span></span><br><span class="line">        <span class="keyword">return</span> img1</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function">(<span class="params">img1</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(img1.height)</span><br><span class="line">        <span class="comment">// 返回一个 Promise 实例</span></span><br><span class="line">        <span class="keyword">return</span> loadImg(url2)</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function">(<span class="params">img2</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(img2.width)</span><br><span class="line">        <span class="keyword">return</span> img2</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function">(<span class="params">img2</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(img2.height)</span><br><span class="line">        <span class="keyword">return</span> loadImg(url2)</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(err)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端面试题</category>
      </categories>
      <tags>
        <tag>JS基础</tag>
        <tag>知识点总结</tag>
        <tag>变量类型和计算</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面试题总结-JS基础之变量类型和计算</title>
    <url>/2020/11/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93-JS%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%AE%A1%E7%AE%97/</url>
    <content><![CDATA[<p><strong>变量是每个语言最开始的基础，不会变量，别说你会JS！</strong></p>
<h1 id="变量类型和计算"><a href="#变量类型和计算" class="headerlink" title="变量类型和计算"></a>变量类型和计算</h1><h2 id="值类型与引用类型的区别"><a href="#值类型与引用类型的区别" class="headerlink" title="值类型与引用类型的区别"></a>值类型与引用类型的区别</h2><a id="more"></a>

<p>先看两段代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 值类型</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">let</span> b = a;</span><br><span class="line">a = <span class="number">200</span>;</span><br><span class="line"><span class="built_in">console</span>.log(b)  <span class="comment">// 100</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引用类型</span></span><br><span class="line"><span class="keyword">let</span> a = &#123; age = <span class="number">18</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> b = a;</span><br><span class="line">b.age = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a.age) <span class="comment">// 20</span></span><br></pre></td></tr></table></figure>

<p>深入分析</p>
<p><strong>通过第一个值类型来看</strong>，首先变量一般会在函数中或者全局中出现，无论是函数还是全局中，值类型都是通过在栈（计算机的内存结构）中存储的，示意图如下</p>
<p><img src="1606179634158.png" alt="1606179634158"></p>
<p><strong>通过第二个引用类型来看</strong>，在计算机变量存储的时候，栈和堆是同时存在的，栈是从上到下一层层累加，而堆是从下往上一层层落，因此在age = 20的这个对象在堆中申请一个内存地址，然后把age = 20放在堆里面，然后key中存储对应的内存地址，而这个时候栈中存储的a的value指向的是内存地址1，也就是说并不是直接存储的对象，而是存储的这个内存地址指向这个对象，示意图如下</p>
<p><img src="1606180185281.png" alt="1606180185281"></p>
<h3 id="常见的值类型与引用类型"><a href="#常见的值类型与引用类型" class="headerlink" title="常见的值类型与引用类型"></a>常见的值类型与引用类型</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 常见值类型</span></span><br><span class="line"><span class="keyword">let</span> a                  <span class="comment">//undefined（如果是const a必须要赋值，如果不赋值直接报错而不是undefined）</span></span><br><span class="line"><span class="keyword">const</span> s = <span class="string">&#x27;abc&#x27;</span>        <span class="comment">// String</span></span><br><span class="line"><span class="keyword">const</span> n = <span class="number">100</span>          <span class="comment">// Number</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="literal">true</span>         <span class="comment">// Boolean</span></span><br><span class="line"><span class="keyword">const</span> s = <span class="built_in">Symbol</span>(<span class="string">&#x27;s&#x27;</span>)  <span class="comment">// ES6新增</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 常见引用类型</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">x</span>: <span class="number">100</span> &#125;</span><br><span class="line"><span class="keyword">const</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"><span class="keyword">const</span> n = <span class="literal">null</span>     <span class="comment">// 特殊引用类型，指针指向为空地址</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;&#125;   <span class="comment">// 特殊引用类型，但不用与存储数据，所以没有&quot;拷贝、赋值函数&quot;这一说</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例题</span></span><br><span class="line"><span class="keyword">const</span> obj1 = &#123; <span class="attr">x</span>: <span class="number">100</span>, <span class="attr">y</span>: <span class="number">200</span> &#125;</span><br><span class="line"><span class="keyword">const</span> obj2 = obj1</span><br><span class="line"><span class="keyword">let</span> x1 = obj1.x      <span class="comment">// x1 为值类型，直接就把100赋值过去</span></span><br><span class="line">obj2.x = <span class="number">101</span></span><br><span class="line">x1 = <span class="number">102</span>			<span class="comment">// x1的改变与引用类型没有关系</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1)    <span class="comment">// &#123; x: 100, y: 200 &#125;</span></span><br></pre></td></tr></table></figure>

<p><em>注：</em>至于值类型与引用类型是不同的赋值形式，原因是<strong>考虑到性能或者存储</strong>的问题，<strong>值类型占用的空间较少</strong>（因为只有一个值），所以直接放在栈里面同时复制的时候也不会对性能造成很大的影响；而<strong>引用类型中的Json对象可能非常大</strong>，第一：直接放到栈的值里面会导致存储地址非常大，不好管理。第二：如果复制的时候直接复制value会导致复制过程非常的慢。因此<strong>计算机所有的程序，所有的代码，所有的语言都是采用值类型与引用类型严格的分离出来</strong>，它们的<strong>存储机制</strong>、<strong>赋值机制</strong>、<strong>拷贝机制</strong>也是严格的区分出来，它是<strong>基于内存的空间与CPU计算的耗时</strong>做到这样的区分。让引<strong>用类型也类似于值类型赋值方式</strong>，就<strong>需要深拷贝</strong>。</p>
<h2 id="typeof运算符"><a href="#typeof运算符" class="headerlink" title="typeof运算符"></a>typeof运算符</h2><ul>
<li>识别所有值类型</li>
<li>识别函数</li>
<li>判断是否是引用类型（不可再细分）</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断所有值类型</span></span><br><span class="line"><span class="keyword">let</span> a;                  <span class="keyword">typeof</span> a   <span class="comment">// &#x27;undefined&#x27;</span></span><br><span class="line"><span class="keyword">const</span> str = <span class="string">&#x27;abc&#x27;</span>;      <span class="keyword">typeof</span> str <span class="comment">// &#x27;string&#x27;</span></span><br><span class="line"><span class="keyword">const</span> n = <span class="literal">true</span>;         <span class="keyword">typeof</span> n   <span class="comment">// &#x27;boolean&#x27;</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="number">100</span>;          <span class="keyword">typeof</span> b   <span class="comment">// &#x27;number&#x27;</span></span><br><span class="line"><span class="keyword">const</span> s = <span class="built_in">Symbol</span>(<span class="string">&#x27;s&#x27;</span>);  <span class="keyword">typeof</span> s   <span class="comment">// &#x27;symbol&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 能判断函数</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">console</span>.log       <span class="comment">// &#x27;function&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;     <span class="comment">// &#x27;function&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 能识别引用类型（不能再继续识别数组、null这些，只能归为object）</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>        <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]  <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> &#123; <span class="attr">x</span>: <span class="number">100</span> &#125;  <span class="comment">// &#x27;object&#x27;</span></span><br></pre></td></tr></table></figure>



<h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><p>浅拷贝</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 浅拷贝，浅拷贝只是拷贝了引用对象存储栈中的value（内存地址），所以任意的修改会造成堆中值的修改</span></span><br><span class="line"><span class="keyword">const</span> obj1 = &#123;</span><br><span class="line">    age: <span class="number">20</span>,</span><br><span class="line">    name: <span class="string">&#x27;xxx&#x27;</span>,</span><br><span class="line">    address: &#123;</span><br><span class="line">        city: <span class="string">&#x27;beijing&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    arr: [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj2 = obj1</span><br><span class="line">obj2.address.city = <span class="string">&#x27;tieling&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1.adress.city)   <span class="comment">// tieling</span></span><br></pre></td></tr></table></figure>

<p>深拷贝</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 若只想修改obj2而不干扰到obj1，所以就需要深拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// obj 是 null， 或者 obj 不是对象或者数组，就没必要做深拷贝</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span> || <span class="keyword">typeof</span> obj == <span class="string">&#x27;null&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化返回结果</span></span><br><span class="line">    <span class="keyword">let</span> result</span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="built_in">Array</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果是数组，就将返回结果初始化为空数组</span></span><br><span class="line">        result = []</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果是对象，就将返回结果初始化为空对象</span></span><br><span class="line">        result = &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 无论是对象或者数组都可以用 for in 做遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="comment">// 保证key不是原型的属性，而是自身特有的</span></span><br><span class="line">        <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">            <span class="comment">// 递归调用！防止剩余深层次的内容</span></span><br><span class="line">            <span class="comment">// result[key] = &#123; key1: &#123; key2: obj[key][key1][key2] &#125; &#125; 如果还有就一直循环下去</span></span><br><span class="line">            result[key] = deepClone(obj[key])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将结果返回出去</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时就可以通过下面这一行代码实现深拷贝</span></span><br><span class="line"><span class="keyword">const</span> obj2 = deepClone(obj1)</span><br></pre></td></tr></table></figure>



<h2 id="变量计算-类型转换"><a href="#变量计算-类型转换" class="headerlink" title="变量计算-类型转换"></a>变量计算-类型转换</h2><p><em>最容易考察也是最容易疏忽的地方</em></p>
<ul>
<li>字符串拼接</li>
<li>==   （等号运算符）</li>
<li>if语句和逻辑运算</li>
</ul>
<h3 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">100</span> + <span class="number">10</span>       <span class="comment">// 110</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="number">100</span> + <span class="string">&#x27;10&#x27;</span>     <span class="comment">// &#x27;10010&#x27;</span></span><br><span class="line"><span class="keyword">const</span> c = <span class="literal">true</span> + <span class="string">&#x27;10&#x27;</span>    <span class="comment">// &#x27;true10&#x27;</span></span><br><span class="line"><span class="keyword">const</span> d = <span class="literal">true</span> + <span class="number">1</span>       <span class="comment">// 2</span></span><br><span class="line"><span class="keyword">const</span> f = <span class="literal">false</span> - <span class="number">1</span>      <span class="comment">// -1</span></span><br></pre></td></tr></table></figure>

<h3 id="运算符"><a href="#运算符" class="headerlink" title="== 运算符"></a>== 运算符</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 会发生隐式的转换，让他们尝试相等</span></span><br><span class="line"><span class="number">100</span> == <span class="string">&#x27;100&#x27;</span>        <span class="comment">// true</span></span><br><span class="line"><span class="number">0</span> == <span class="string">&#x27;&#x27;</span>             <span class="comment">// true</span></span><br><span class="line"><span class="number">0</span> == <span class="literal">false</span>          <span class="comment">// true</span></span><br><span class="line"><span class="literal">false</span> == <span class="string">&#x27;&#x27;</span>         <span class="comment">// true</span></span><br><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span>   <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 除了 == null （判断一个对象属性是null或undefined）之外，在实际开发中其他一律用 === ，例如</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">x</span>: <span class="number">100</span> &#125;</span><br><span class="line"><span class="keyword">if</span> (obj.a == <span class="literal">null</span>) &#123; &#125;</span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="comment">// if (obj.a === null || obj.a === undefined) &#123; &#125;</span></span><br></pre></td></tr></table></figure>



<h2 id="if语句和逻辑运算"><a href="#if语句和逻辑运算" class="headerlink" title="if语句和逻辑运算"></a>if语句和逻辑运算</h2><ul>
<li><p>truly变量：!!a === true 的变量</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> n = <span class="number">100</span></span><br><span class="line"><span class="built_in">console</span>.log(!n);   <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(!!n)   <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>falsely变量：!!a === false 的变量</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> n = <span class="number">0</span></span><br><span class="line"><span class="built_in">console</span>.log(!n);   <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(!!n)   <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(!!<span class="literal">null</span>)        <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(!!<span class="string">&#x27;&#x27;</span>)          <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(!!<span class="literal">undefined</span>)   <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(!!&#123;&#125;)          <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以下是 falsely 变量。除此之外都是 truly 变量</span></span><br><span class="line">!!<span class="number">0</span> === <span class="literal">false</span></span><br><span class="line">!!<span class="literal">NaN</span> === <span class="literal">false</span></span><br><span class="line">!!<span class="string">&#x27;&#x27;</span> === <span class="literal">false</span></span><br><span class="line">!!<span class="literal">null</span> === <span class="literal">false</span></span><br><span class="line">!!<span class="literal">undefined</span> === <span class="literal">false</span></span><br><span class="line">!!<span class="literal">false</span> === <span class="literal">false</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<p><strong>实际上 if 语句里面判断的不是 true 或者 false ，判断的是 truly 或者 falsely 变量</strong></p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// truly 变量</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="literal">true</span></span><br><span class="line"><span class="keyword">if</span> (a) &#123; <span class="comment">// ... &#125;</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="number">100</span></span><br><span class="line"><span class="keyword">if</span> (b) &#123; <span class="comment">// ... &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// falsely 变量</span></span><br><span class="line"><span class="keyword">const</span> c = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">if</span> (c) &#123; <span class="comment">// ... &#125;</span></span><br><span class="line"><span class="keyword">const</span> d = <span class="literal">null</span></span><br><span class="line"><span class="keyword">if</span> (d) &#123; <span class="comment">// ... &#125;</span></span><br><span class="line"><span class="keyword">let</span> e</span><br><span class="line"><span class="keyword">if</span> (e) &#123; <span class="comment">// ... &#125;</span></span><br></pre></td></tr></table></figure>



<h2 id="逻辑判断"><a href="#逻辑判断" class="headerlink" title="逻辑判断"></a>逻辑判断</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">10</span> &amp;&amp; <span class="number">0</span>)        <span class="comment">// 0      &amp;&amp; 第一个值为true则返回第二个，第一个值为false则返回第一个</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;&#x27;</span> || <span class="string">&#x27;abc&#x27;</span>)    <span class="comment">// &#x27;abc&#x27;  || 第一个值为false则返回第二个，第一个为true则返回第一个</span></span><br><span class="line"><span class="built_in">console</span>.log(!<span class="built_in">window</span>.abc)    <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端面试题</category>
      </categories>
      <tags>
        <tag>JS基础</tag>
        <tag>知识点总结</tag>
        <tag>变量类型和计算</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面试题总结-JS基础之原型和原型链</title>
    <url>/2020/11/25/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93-JS%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    <content><![CDATA[<p><strong>三座大山之一，必考！！！</strong></p>
<p>JS本身是一个基于原型基层的语言，ES6之前，写继承的时候只能通过原型来继承，ES6出来之后引入了 class 语法，可以通过 class 继承，但是基于对 class 的剖解来看，class 真正上的继承还是原型上的继承。</p>
<a id="more"></a>

<h1 id="如何用Class实现继承"><a href="#如何用Class实现继承" class="headerlink" title="如何用Class实现继承"></a>如何用Class实现继承</h1><h2 id="class"><a href="#class" class="headerlink" title="class"></a>class</h2><p>class 本质上就类似于一个模版，我们可以通过模版去构建一些东西。</p>
<ul>
<li>constructor</li>
<li>属性</li>
<li>方法</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name, number</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name</span><br><span class="line">        <span class="built_in">this</span>.number = number</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">sayHi</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(</span><br><span class="line">            <span class="comment">// 模版字符串</span></span><br><span class="line">            <span class="string">`姓名:<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>, 学号:<span class="subst">$&#123;<span class="built_in">this</span>.number&#125;</span>`</span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过类 new 对象/实例  (可以 new n多个对象)</span></span><br><span class="line"><span class="keyword">let</span> xiaoa = <span class="keyword">new</span> Student(<span class="string">&#x27;小A&#x27;</span>, <span class="number">18</span>)</span><br><span class="line"><span class="built_in">console</span>.log(xiaoa.name)    <span class="comment">// 小A</span></span><br><span class="line"><span class="built_in">console</span>.log(xiaoa.number)  <span class="comment">// 18</span></span><br><span class="line">xiaoa.sayHi()              <span class="comment">// 姓名:小A, 学号:18</span></span><br></pre></td></tr></table></figure>



<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>当我们有很多个 class ，这些 class 有一些比较公共的属性的时候，就可以把它抽离出来，让后让这些 class 继承。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">eat</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> eat something`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Student子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name, number</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 调用 super 把 name 给 people 的 constructor</span></span><br><span class="line">        <span class="comment">// 然后把名字赋值到属性上</span></span><br><span class="line">        <span class="built_in">super</span>(name)</span><br><span class="line">        <span class="built_in">this</span>.number = number</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">sayHi</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`姓名:<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>,学号<span class="subst">$&#123;<span class="built_in">this</span>.number&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// teacher子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">extends</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name, major</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name)</span><br><span class="line">        <span class="built_in">this</span>.major = major</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">teach</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> 教授 <span class="subst">$&#123;<span class="built_in">this</span>.major&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> s1 = <span class="keyword">new</span> Student(<span class="string">&#x27;A同学&#x27;</span>, <span class="number">66</span>)</span><br><span class="line"><span class="built_in">console</span>.log(s1.name)      <span class="comment">// A同学</span></span><br><span class="line"><span class="built_in">console</span>.log(s1.number)	  <span class="comment">// 66</span></span><br><span class="line">s1.sayHi()				 <span class="comment">// 姓名:A同学,学号66</span></span><br><span class="line">s1.eat()                  <span class="comment">// A同学 eat something</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> t1 = <span class="keyword">new</span> Teacher(<span class="string">&#x27;C老师&#x27;</span>, <span class="string">&#x27;语文&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(t1.name)     <span class="comment">// C老师</span></span><br><span class="line"><span class="built_in">console</span>.log(t1.major)    <span class="comment">// 语文</span></span><br><span class="line">t1.teach()               <span class="comment">// C老师 教授 语文</span></span><br><span class="line">t1.eat()                 <span class="comment">// C老师 eat something</span></span><br></pre></td></tr></table></figure>



<h1 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a>类型判断</h1><p>主要是判断 instanceof 前面的是否由 instanceof 后面的构建出来的，接上面代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123; &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">People</span> </span>&#123; &#125;</span><br><span class="line"><span class="keyword">const</span> s1 = <span class="keyword">new</span> Student()</span><br><span class="line"></span><br><span class="line">s1 <span class="keyword">instanceof</span> Student     <span class="comment">// true</span></span><br><span class="line">s1 <span class="keyword">instanceof</span> People      <span class="comment">// true   People 是 Student 的父类，也参与了构建的一部分</span></span><br><span class="line">s1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>      <span class="comment">// true   Object 是所有 class 的父类</span></span><br><span class="line"></span><br><span class="line">[] <span class="keyword">instanceof</span> <span class="built_in">Array</span>       <span class="comment">// true</span></span><br><span class="line">[] <span class="keyword">instanceof</span> <span class="built_in">Object</span>      <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Array</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>   <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">&#123;&#125; <span class="keyword">instanceof</span> <span class="built_in">Object</span>      <span class="comment">// true</span></span><br></pre></td></tr></table></figure>



<h1 id="JS原型"><a href="#JS原型" class="headerlink" title="JS原型"></a>JS原型</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123; &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">People</span> </span>&#123; &#125;</span><br><span class="line"><span class="keyword">const</span> s1 = <span class="keyword">new</span> Student()</span><br><span class="line"></span><br><span class="line"><span class="comment">// class 实际上是函数，可见是语法糖</span></span><br><span class="line"><span class="keyword">typeof</span> People   <span class="comment">// &#x27;function&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> Student  <span class="comment">// &#x27;function&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐式原型和显式原型</span></span><br><span class="line"><span class="built_in">console</span>.log( s1.__proto__ )        <span class="comment">// 隐式原型</span></span><br><span class="line"><span class="built_in">console</span>.log( Student.prototype )   <span class="comment">// 显式原型</span></span><br><span class="line"><span class="built_in">console</span>.log( s1.__proto__ === Student.prototype )  <span class="comment">// true 也就是两个引用的是一个内存地址</span></span><br></pre></td></tr></table></figure>

<p>在定义 class Student 的时候会有一个显式原型（prototype）指向一个对象（Student.prototype），并且把方法（sayHi）放在这个对象（Student.prototype）里面，通过 new 一个实例对象 s1 之后，他的 name、number 会放在实例对象 s1 本身，而这里的 sayHi 方法是通过隐式原型指向（Student.prototype）里面的方法来获取的。</p>
<img src="1606225829665.png" alt="1606225829665" style="zoom: 67%;" />



<h2 id="原型关系"><a href="#原型关系" class="headerlink" title="原型关系"></a>原型关系</h2><ul>
<li>每个 class 都有显式原型 prototype</li>
<li>每个实例都有隐式原型 __ proto __</li>
<li>实例的隐式原型 __ proto __ 指向对应的 class 的显示原型 prototype</li>
</ul>
<h2 id="基于原型的执行规则"><a href="#基于原型的执行规则" class="headerlink" title="基于原型的执行规则"></a>基于原型的执行规则</h2><ul>
<li><p>获取属性 s1.name 或执行方法 s1.sayHi() 时</p>
</li>
<li><p>先在自身属性和方法寻找</p>
</li>
<li><p>如果找不到则自动去隐式原型 __ proto __ 中查找 </p>
<p>例如获取 s1.sayHi（），此时 s1 自身并没有 sayHi 方法，因此去 s1 的 __ proto __ 中查找，而隐式原型正好指向 class 的显式原型 Student.prototype ，然后就找到了 sayHi 方法。</p>
</li>
</ul>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123; &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">People</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Student.prototype.__proto__)</span><br><span class="line"><span class="built_in">console</span>.log(People.prototype)</span><br><span class="line"><span class="built_in">console</span>.log(People.prototype === Student.prototype.__proto__)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>首先，左下角三个图的关系对应上一张图。但这里的 Student 的显式原型（Student.prototype）还会有一个隐式原型，指向了 People 的显式原型（People.prototype）,People原型里面有 eat 方法。</p>
<p>逻辑上来讲，实例 s1 是通过 Student new 出来的，所以 s1 的隐式原型指向 Student 的显式原型。其次可以理解为 Student 的显式原型对象（Student.prototype）是通过 People new 出来的，所以 Student.prototype 的隐式原型指向 People 的显式原型（People.prototype）,</p>
<img src="1606262732500.png" alt="1606262732500" style="zoom: 80%;" />

<p>整体上说：</p>
<ul>
<li><p>访问 s1.name/number 是通过 s1 本身属性；</p>
</li>
<li><p>访问 s1.sayHi() ,此时由于 s1 本身没有 sayHi 方法，所以通过隐式原型指向的 Student 上的显式原型对象找到 sayHi 方法；</p>
</li>
<li><p>访问 s1.eat() , s1 的身上与其身上隐式原型指向的 Student.prototype 都没有此方法，因此再通过 Student.prototype 上的隐式原型指向的 People.prototype 上来找到 eat 方法（由此形成了一个链）</p>
</li>
</ul>
<p>我们可以通过 s1.hasOwnProperty(‘属性’) 来判断某个属性或方法是否为自身拥有，那么 hasOwnProperty() 方法是哪里来的？</p>
<p>从下图可以看出 Student 继承于 People ， People 继承于 Object ，所以说 People 的显式原型对象中也有隐式原型，并且指向 Object 的显式原型对象 Object.prototype （JS 引擎本身自己带的），Object 原型里面有很多方法。</p>
<p><strong>因此 s1 访问 hasOwnProperty 方法，就会通过这个原型链来一级一级查找，最终在基类 Object 的显式原型上找到 hasOwnProperty 方法</strong></p>
<img src="1606264497414.png" alt="1606264497414" style="zoom:80%;" />

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基类 Object 的显式原型对象身上的隐式原型永远指向 null </span></span><br><span class="line"><span class="comment">// 因此基类 Object 的显式原型对象为原型链的最后一级</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.__proto__     <span class="comment">// null</span></span><br></pre></td></tr></table></figure>



<h3 id="再看-instanceof"><a href="#再看-instanceof" class="headerlink" title="再看 instanceof"></a>再看 instanceof</h3><p>还是这张图， instanceof 前面的变量顺着隐式原型往上找，如果能对应到 instanceof 后面的参数 class 的显式原型（或者原型链上的显式原型），如果能对应到，那么 instanceof 成立返回 true，如果对应不到就返回 false ，</p>
<img src="1606264497414.png" alt="1606264497414" style="zoom:80%;" />



<h2 id="重要提示！！！"><a href="#重要提示！！！" class="headerlink" title="重要提示！！！"></a>重要提示！！！</h2><ul>
<li>class 是 ES6 语法规范，由 ECMA 委员会发布</li>
<li>ECMA 只规定语法规则，即我们代码的书写规范，不规定如何实现</li>
<li>以上实现方式都是 V8 引擎的实现方式，也是主流的</li>
</ul>
<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a><strong>题目</strong></h1><ul>
<li><p>如何准确判断一个变量是不是数组？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 结合原型链的图理解 instanceof </span></span><br><span class="line"><span class="keyword">const</span> a = []</span><br><span class="line">a <span class="keyword">instanceof</span> <span class="built_in">Array</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从原型入手: Array.prototype.isPrototypeOf(obj)</span></span><br><span class="line"><span class="comment">// 利用isPrototypeOf()方法，判定Array是不是在obj的原型链中如果是，则返回true,否则false。</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.isPrototypeOf(a)   <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>class 的原型本质，怎么理解？</p>
<ul>
<li>每个 class 都有显式原型 prototype</li>
<li>每个实例都有隐式原型 __ proto __</li>
<li>实例的隐式原型 __ proto __ 指向对应的 class 的显示原型 prototype</li>
<li>获取实例身上属性或执行方法时，先在自身属性和方法寻找，如果找不到则自动去隐式原型指向的父类显式原型对象中查找 ，然后顺着与原型链去查找。</li>
</ul>
</li>
<li><p>手写一个简易的 jQuery，考虑插件和扩展性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">jQuery</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">selector</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 首先 DOM 查询</span></span><br><span class="line">        <span class="keyword">const</span> result = <span class="built_in">document</span>.querySelectorAll(selector)</span><br><span class="line">        <span class="keyword">const</span> length = result.length</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对查出的结果进行遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="comment">// 把遍历的每个结果都放到 this 上</span></span><br><span class="line">            <span class="built_in">this</span>[i] = result[i]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.length = length</span><br><span class="line">        <span class="built_in">this</span>.selector = selector</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// jQuery 中的 get 方法</span></span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params">index</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>[index]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// each 遍历</span></span><br><span class="line">    <span class="function"><span class="title">each</span>(<span class="params">fn</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.length; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> elem = <span class="built_in">this</span>[i]</span><br><span class="line">            fn(elem)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// on 监听方法</span></span><br><span class="line">    <span class="function"><span class="title">on</span>(<span class="params">type, fn</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.each(<span class="function"><span class="params">elem</span> =&gt;</span> &#123;</span><br><span class="line">            elem.addEventListener(type, fn, <span class="literal">false</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 还可扩展很多 DOM 操作 API</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// const $p = new jQuery(&#x27;p&#x27;)</span></span><br><span class="line"><span class="comment">// $p.get(1)</span></span><br><span class="line"><span class="comment">// $p.each((elem) =&gt; console.log(elem.nodeName))</span></span><br><span class="line"><span class="comment">// $p.on(&#x27;click&#x27;, () =&gt; alert(&#x27;clicked&#x27;))</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 插件机制（做一个插件，但其实用的还是 jQuery）</span></span><br><span class="line">jQuery.prototype.dialog = <span class="function"><span class="keyword">function</span> (<span class="params">info</span>) </span>&#123;</span><br><span class="line">    alert(info)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// $p.dialog(&#x27;123456&#x27;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;造轮子&quot; (复写机制)</span></span><br><span class="line"><span class="comment">// 就是基于这个 jQuery 去造一个更加完美的 myJQuery 供使用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myJQuery</span> <span class="keyword">extends</span> <span class="title">jQuery</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">selector</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// super 的好处体现，直接使用 jQuery 的复杂 constructor，无需再写一遍逻辑</span></span><br><span class="line">        <span class="built_in">super</span>(selector)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩展自己的方法...</span></span><br><span class="line">    <span class="function"><span class="title">addClass</span>(<span class="params">className</span>)</span> &#123; &#125;</span><br><span class="line">    <span class="function"><span class="title">style</span>(<span class="params">data</span>)</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <categories>
        <category>前端面试题</category>
      </categories>
      <tags>
        <tag>JS基础</tag>
        <tag>知识点总结</tag>
        <tag>原型和原型链</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面试题总结-http 面试题</title>
    <url>/2020/12/09/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93-http-%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<p>前后端分离的时代，网络请求是前端的生命线！</p>
<p>http 面试题</p>
<ul>
<li>前端工程师开发界面</li>
<li>需要调用后端的接口，提交/获取 数据 —— http 协议</li>
<li>要求事先掌握好 ajax</li>
</ul>
<a id="more"></a>

<p>首先看题目</p>
<ul>
<li>http 常见的状态码有哪些？</li>
<li>http 常见的 header 有哪些？</li>
<li>什么是 Restful api</li>
<li>描述一下 http 的缓存机制（重要）</li>
</ul>
<h1 id="http-状态码"><a href="#http-状态码" class="headerlink" title="http 状态码"></a>http 状态码</h1><h2 id="状态码分类"><a href="#状态码分类" class="headerlink" title="状态码分类"></a>状态码分类</h2><ul>
<li>1xx 服务器接收到请求</li>
<li>2xx 请求成功，如 200</li>
<li>3xx 重定向，如 302</li>
<li>4xx 客户端错误，如 404</li>
<li>5xx 服务器端错误，如 500</li>
</ul>
<h2 id="常见状态码"><a href="#常见状态码" class="headerlink" title="常见状态码"></a>常见状态码</h2><ul>
<li>200 成功</li>
<li>301 永久重定向（配合 location 新的地址，浏览器自动处理）</li>
<li>302 临时重定向（配合 location 新的地址，浏览器自动处理）</li>
<li>304 资源未被修改</li>
<li>404 资源未找到</li>
<li>403 没有权限</li>
<li>500 服务器错误</li>
<li>504 网关超时</li>
</ul>
<h1 id="http-methods"><a href="#http-methods" class="headerlink" title="http methods"></a>http methods</h1><h2 id="传统的-methods"><a href="#传统的-methods" class="headerlink" title="传统的 methods"></a>传统的 methods</h2><ul>
<li>get 获取服务器的数据</li>
<li>post 向服务器提交数据</li>
<li>简单的网页功能就这两个操作</li>
</ul>
<h2 id="现在的-methods"><a href="#现在的-methods" class="headerlink" title="现在的 methods"></a>现在的 methods</h2><ul>
<li>get 获取数据</li>
<li>post 新建数据（数据还没有，要创建一个新的，比如一个新的留言、新的博客）</li>
<li>patch / put 更新数据</li>
<li>delete 删除数据</li>
</ul>
<h1 id="Restful-API"><a href="#Restful-API" class="headerlink" title="Restful API"></a>Restful API</h1><ul>
<li>一种新的 API 设计方法（早已推广使用）</li>
<li><strong>传统 API 设计：把每个 url 当做一个功能</strong></li>
<li><strong>Restful API 设计：把每个 url 当做一个唯一的资源的标识</strong></li>
</ul>
<h2 id="如何设计一个唯一的资源"><a href="#如何设计一个唯一的资源" class="headerlink" title="如何设计一个唯一的资源"></a>如何设计一个唯一的资源</h2><ul>
<li><p><strong>尽量不用 url 参数</strong></p>
<p><strong>传统 API 设计</strong>：      /api/list?pageInde=2 ，有点像问号前面是一个函数，然后问号后面是一个参数</p>
<p><strong>Restful API 设计</strong>： /api/list/2 ，就是一个资源的标识，不会与其他重复</p>
</li>
<li><p><strong>用 method 表示操作类型</strong></p>
<p><strong>传统 API 设计</strong></p>
<p>​    post 请求： /api/create-blog</p>
<p>​    post 请求： /api/update-blog?id=100</p>
<p>​    get 请求：   /api/get-blog?id=100</p>
<p><strong>Restful API 设计</strong></p>
<p>​    post请求：    /api/blog<br>​    patch请求：  /api/blog/100<br>​    get请求：      /api/blog/100</p>
</li>
</ul>
<h1 id="http-headers"><a href="#http-headers" class="headerlink" title="http headers"></a>http headers</h1><h2 id="常见的-Request-Headers"><a href="#常见的-Request-Headers" class="headerlink" title="常见的 Request Headers"></a>常见的 Request Headers</h2><ul>
<li>Accept：浏览器可接收的数据格式</li>
<li>Accept-Encoding：浏览器可接收的压缩算法，如 gzip (如原来内容100kb，最小压缩到 30kb)</li>
<li>Accept-Language：浏览器可接受的语言，如 zh-CN</li>
<li>Connection:keep-aive 一次 TCP 连接重复使用</li>
<li>cookie</li>
<li>Host：域名</li>
<li>User-Agent（简称 UA）浏览器信息</li>
<li>Content-type：发送数据的格式，如 application/json</li>
</ul>
<h2 id="常见的-Response-Headers"><a href="#常见的-Response-Headers" class="headerlink" title="常见的 Response Headers"></a>常见的 Response Headers</h2><ul>
<li>Content-type：返回数据的格式，如 application/json</li>
<li>Content-length：返回数据的大小，多少字节</li>
<li>Content-Encoding：返回数据的压缩算法，如 gzip</li>
<li>Set-Cookie</li>
</ul>
<h1 id="http-缓存策略"><a href="#http-缓存策略" class="headerlink" title="http 缓存策略"></a>http 缓存策略</h1><h2 id="关于缓存"><a href="#关于缓存" class="headerlink" title="关于缓存"></a>关于缓存</h2><p>当第一次用浏览器访问一个新的网站时（本地无该网站任何信息），服务端会原原本本把所有的数据返回给浏览器，但是当第二次访问时，可以把没有必要重新获取的东西不再重新获取。</p>
<h2 id="关于为什么需要缓存"><a href="#关于为什么需要缓存" class="headerlink" title="关于为什么需要缓存"></a>关于为什么需要缓存</h2><p>最大的目的是为了让页面加载的更快一些。</p>
<p>网络请求的加载到相比于 CPU 的计算，包括页面的渲染都是非常慢的一个事情，所以如果要做性能优化，让页面显示的更快，因此要从最带的瓶颈——网络请求下手，<strong>尽量减少网络请求的体积和数量，让网络请求更快一些</strong>。</p>
<p>**可以被缓存的资源 **—— 静态资源（js、css、img），可根据文件内容生成一个哈希值，如果内容变了，哈希值会变，输出的文件名也会变，这样文件缓存就没有问题了，但访问 html 时无法再后面加入哈希值。</p>
<h2 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h2><p>初次请求，浏览器返回资源和 Cache-Control ，浏览器有了资源之后可继续工作，这个时候如果服务端感觉资源可以被缓存，就会加一个 Cache-Control ，如果服务端感觉资源不适合被缓存就不会加 Cache-Control 。</p>
<img src="image-20201208212554249.png" alt="image-20201208212554249" style="zoom: 33%;" />

<h3 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h3><ul>
<li>在 Response Headers 中（服务端控制）</li>
<li>控制强制缓存的逻辑</li>
<li>例如 Cache- Control:max-age=31536000（单位是秒），一年</li>
</ul>
<p>百度的 logo  Cache- Control 是一年</p>
<img src="image-20201208213526848.png" alt="image-20201208213526848" style="zoom: 50%;" />

<p>因此在此请求的时候只要判断 Cache- Control 时间还没过期，然后浏览器就会在本地缓存里面去找这个资源，不会到服务端，然后直接返回这个资源。因此该次请求未经过网络，直接读取的本地缓存会非常快，所以此次请求会更快一些，</p>
<img src="image-20201208213852916.png" alt="image-20201208213852916" style="zoom: 33%;" />

<img src="image-20201208214312281.png" alt="image-20201208214312281" style="zoom: 50%;" />

<p>如果缓存过期失效了，就会再次请求服务端，服务端重新返回资源和 Cache- Control ，然后又会设置一遍过期时间，这样如果近期再请求，就会命中了本地缓存，很快的返回资源。</p>
<img src="image-20201208214414482.png" alt="image-20201208214414482" style="zoom:33%;" />

<h3 id="Cache-Control-的值"><a href="#Cache-Control-的值" class="headerlink" title="Cache- Control 的值"></a>Cache- Control 的值</h3><ul>
<li>max-age：缓存最大过期时间</li>
<li>no-cache：不用强制缓存，正常向服务端请求</li>
<li>no-store：不用强制缓存而且不用服务端的缓存措施，直接简单粗暴的把资源再重新返回一份，比较彻底，但不常见</li>
<li>private</li>
<li>public</li>
</ul>
<h3 id="关于-Expries（知道即可）"><a href="#关于-Expries（知道即可）" class="headerlink" title="关于 Expries（知道即可）"></a>关于 Expries（知道即可）</h3><ul>
<li>同在 Response Headers 中</li>
<li>同为控制缓存过期</li>
<li>已被 Cache- Control 代替</li>
</ul>
<h2 id="协商缓存（对比缓存）"><a href="#协商缓存（对比缓存）" class="headerlink" title="协商缓存（对比缓存）"></a>协商缓存（对比缓存）</h2><ul>
<li>服务器端缓存策略（服务端判断资源是否可以用浏览器中缓存的内容）</li>
<li>服务器判断客户端资源，是否和服务端资源一样</li>
<li>一致则返回 304，否则返回 200 和最新的资源</li>
</ul>
<img src="image-20201208220028941.png" alt="image-20201208220028941" style="zoom:33%;" />

<h3 id="资源标识"><a href="#资源标识" class="headerlink" title="资源标识"></a>资源标识</h3><p>在 Response Headers （因为是服务端返回的）中，有两种：</p>
<ul>
<li>Last-Modified 资源的最后修改时间</li>
<li>Etag 资源的唯一标识（一个字符串，类似人类的指纹）</li>
</ul>
<h4 id="Last-Modified"><a href="#Last-Modified" class="headerlink" title="Last-Modified"></a>Last-Modified</h4><p>If-Modified-Since 永远返回浏览器缓存中最近一次修改的时间</p>
<img src="image-20201208220458639.png" alt="image-20201208220458639" style="zoom:33%;" />

<h4 id="Etag"><a href="#Etag" class="headerlink" title="Etag"></a>Etag</h4><p>If-None-Match 就是上一次服务器端返回的 Etag 字符串</p>
<img src="image-20201208220923688.png" alt="image-20201208220923688" style="zoom:33%;" />

<img src="image-20201208221644782.png" alt="image-20201208221644782" style="zoom: 33%;" />

<p>第一次访问：</p>
<img src="image-20201208221747981.png" alt="image-20201208221747981" style="zoom:25%;" />

<p>第二次访问（通过 Last-Modified 或 Etag 命中缓存）：</p>
<img src="image-20201208221815899.png" alt="image-20201208221815899" style="zoom:25%;" />

<p>可以看出两次资源请求的 size 差的很多</p>
<h4 id="Last-Modified-和-Etag-共存"><a href="#Last-Modified-和-Etag-共存" class="headerlink" title="Last-Modified 和 Etag 共存"></a>Last-Modified 和 Etag 共存</h4><ul>
<li><p>会优先使用 Etag</p>
<p>Last-Modified 只能精确到秒级，对计算机来说秒级还是一个比较宽泛的时间段，一般以 mm 或以内为单位</p>
</li>
<li><p>如果资源被重复生成，而内容不变，则 Etag 更精确（Etag 根据内容计算），而 Last-Modified 每次都会重新请求</p>
</li>
</ul>
<h2 id="http-缓存-综述"><a href="#http-缓存-综述" class="headerlink" title="http 缓存-综述"></a>http 缓存-综述</h2><img src="image-20201208222322100.png" alt="image-20201208222322100" style="zoom: 50%;" />

<h2 id="三种刷新操作"><a href="#三种刷新操作" class="headerlink" title="三种刷新操作"></a>三种刷新操作</h2><ul>
<li>正常操作：地址栏输入 url，跳转链接，前进后退等</li>
<li>手动刷新：F5，点击刷新按钮，右击菜单刷新</li>
<li>强制刷新：ctrl+F5</li>
</ul>
<h3 id="不同刷新操作，不同的缓存策略"><a href="#不同刷新操作，不同的缓存策略" class="headerlink" title="不同刷新操作，不同的缓存策略"></a>不同刷新操作，不同的缓存策略</h3><ul>
<li>正常操作：强制缓存有效，协商缓存有效</li>
<li>手动刷新：强制缓存失效，协商缓存有效</li>
<li>强制刷新：强制缓存失效，协商缓存失效</li>
</ul>
<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><ul>
<li>http 常见的状态码有哪些</li>
<li>http 常见的 header 有哪些</li>
<li>什么是 Restful API</li>
<li>描述一下 http 的缓存机制（重要，上面流程图一定要会）</li>
</ul>
]]></content>
      <categories>
        <category>前端面试题</category>
      </categories>
      <tags>
        <tag>JS基础</tag>
        <tag>知识点总结</tag>
        <tag>HTTP 面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面试题总结-开发环境</title>
    <url>/2020/12/09/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<p>不会这些，你就会被认定是菜鸟小白，没做过项目</p>
<h1 id="关于开发环境"><a href="#关于开发环境" class="headerlink" title="关于开发环境"></a>关于开发环境</h1><ul>
<li>面试官想通过开发环境了解候选人的实际工作情况</li>
<li>开发环境的工具，能体现工作产出的效率</li>
<li>会以聊天形式为主，不会问具体的问题</li>
</ul>
<a id="more"></a>

<p><strong>开发环境</strong></p>
<ul>
<li>git</li>
<li>调试工具</li>
<li>抓包</li>
<li>webpack、babel</li>
<li>linux 常用命令</li>
</ul>
<h2 id="git"><a href="#git" class="headerlink" title="git"></a>git</h2><ul>
<li>最常用的代码版本管理工具</li>
<li>大型项目需要多人协作开发，必须熟用 git</li>
<li>如果不知道或者之前不用git，不会通过面试</li>
<li>Mac os 自带 git 命令， windows 可去官网下载安装</li>
<li>git 服务端常见的有 github、coding. net 等</li>
<li>大公司会搭建自己的内网 git 服务</li>
</ul>
<h2 id="常用的-git-命令"><a href="#常用的-git-命令" class="headerlink" title="常用的 git 命令"></a>常用的 git 命令</h2><ul>
<li>git add .</li>
<li>git checkout xxx </li>
<li>git commit -m “xxx” </li>
<li>git push origin master </li>
<li>git pull origin master</li>
<li>git branch</li>
<li>git checkout -b xxx</li>
<li>git merge xxx</li>
<li>git diff</li>
<li>git log</li>
<li>git fetch</li>
<li>git stash</li>
<li>git reset –hard id</li>
<li>git stash</li>
<li>git stash pop</li>
</ul>
<p><a href="https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html">常用 Git 命令清单（单击访问）</a></p>
<p><strong>Git 思维导图</strong></p>
<p><img src="https://img-blog.csdn.net/20180808170716549?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA4NTk2NTA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<h2 id="chrome-调试工具"><a href="#chrome-调试工具" class="headerlink" title="chrome 调试工具"></a>chrome 调试工具</h2><ul>
<li>Elements</li>
<li>Console</li>
<li>Network</li>
<li>debugger（需在代码片段中引入该断点命令）</li>
<li>Application</li>
</ul>
<h2 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h2><ul>
<li>移动端 h5 页，查看网络请求，需要用工具抓包</li>
<li>windows 一般用 fiddler </li>
<li>Mac os 一般用 charles</li>
</ul>
<p><strong>移动端</strong>（<a href="https://www.cnblogs.com/yyhh/p/5140852.html">Fiddler抓包工具总结</a>）</p>
<ul>
<li>手机和电脑连同一个局域网</li>
<li>将手机代理到电脑上</li>
<li>手机浏览网页，即可抓包</li>
</ul>
<h2 id="webpack-和-babel"><a href="#webpack-和-babel" class="headerlink" title="webpack 和 babel"></a>webpack 和 babel</h2><ul>
<li>ES6 模块化，浏览器暂不支持</li>
<li>ES6 语法，浏览器并不完全支持</li>
<li>压缩代码，整合代码，以让网页加载更快</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代码演示（需nodejs）</span></span><br><span class="line"><span class="comment">// 根目录 npm init -y</span></span><br><span class="line"><span class="comment">// 接着命令行安装（此处借助淘宝代理） cnpm install webpack webpack-cli -D</span></span><br><span class="line"><span class="comment">// 根目录新建 src 文件夹及子文件 index.js（里面内容随便打印个就可）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根目录新建文件 webpack.config.js ， 内容如下</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    mode: <span class="string">&quot;development&quot;</span>, <span class="comment">// production</span></span><br><span class="line">    entry: path.join(__dirname, <span class="string">&quot;src&quot;</span>, <span class="string">&quot;index.js&quot;</span>), <span class="comment">// 文件入口</span></span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">&quot;bundle.js&quot;</span>,</span><br><span class="line">        path: path.join(__dirname, <span class="string">&quot;dist&quot;</span>),</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 然后可尝试运行（可在 package.json 文件中的 script 里面加入 &quot;build&quot;: &quot;webpack&quot; 简化执行操作）</span></span><br><span class="line"><span class="comment">// 根目录命令行 npm run build</span></span><br><span class="line"><span class="comment">// 打包完毕，根目录会生成 dist 文件夹及子文件 bundle.js</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在网页中显示</span></span><br><span class="line"><span class="comment">// src 文件夹下新建 index.html ,随便生成个 html 框架（无需引入 index.js）</span></span><br><span class="line"><span class="comment">// 命令行安装插件（解析 html） cnpm install html-webpack-plugin -D</span></span><br><span class="line"><span class="comment">// 命令行安装插件（启动服务的插件） cnpm install webpack-dev-server -D</span></span><br><span class="line"><span class="comment">// 安装完成后可在 package.json 的 devDependencies 中查看安装信息</span></span><br><span class="line"><span class="comment">// webpack.config.js 代码</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> htmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&quot;html-webpack-plugin&quot;</span>) <span class="comment">// 引入插件</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    mode: <span class="string">&quot;development&quot;</span>, <span class="comment">// production</span></span><br><span class="line">    entry: path.join(__dirname, <span class="string">&quot;src&quot;</span>, <span class="string">&quot;index.js&quot;</span>), <span class="comment">// 文件入口</span></span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">&quot;bundle.js&quot;</span>,</span><br><span class="line">        path: path.join(__dirname, <span class="string">&quot;dist&quot;</span>),</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 配置插件</span></span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> htmlWebpackPlugin(&#123;</span><br><span class="line">            template: path.join(__dirname, <span class="string">&quot;src&quot;</span>, <span class="string">&quot;index.html&quot;</span>), <span class="comment">// 找到已有的 index.html</span></span><br><span class="line">            filename: <span class="string">&quot;index.html&quot;</span>, <span class="comment">// 产出文件名</span></span><br><span class="line">        &#125;),</span><br><span class="line">    ],</span><br><span class="line">    <span class="comment">// 启动本地服务</span></span><br><span class="line">    devServer: &#123;</span><br><span class="line">        port: <span class="number">3000</span>, <span class="comment">// 端口</span></span><br><span class="line">        contentBase: path.join(__dirname, <span class="string">&quot;dist&quot;</span>), <span class="comment">// 当前目录</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 最终在 package.json 的 scripts 中添加代码： &quot;dev&quot;: &quot;webpack-dev-server&quot;</span></span><br><span class="line"><span class="comment">// 成功之后可在浏览器中访问 http://localhost:3000/index.html 即可</span></span><br><span class="line"><span class="comment">// 能加载出来原因是因为引入了 bundle.js 文件，并且其中包括了 index.js 的代码</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 关于版本报错问题，可尝试下列版本，nodejs 版本过高也可能导致报错</span></span><br><span class="line"><span class="string">&quot;devDependencies&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;html-webpack-plugin&quot;</span>: <span class="string">&quot;^4.5.0&quot;</span>,</span><br><span class="line">  <span class="string">&quot;webpack&quot;</span>: <span class="string">&quot;^4.41.0&quot;</span>,</span><br><span class="line">  <span class="string">&quot;webpack-cli&quot;</span>: <span class="string">&quot;^3.3.9&quot;</span>,</span><br><span class="line">  <span class="string">&quot;webpack-dev-server&quot;</span>: <span class="string">&quot;^3.8.2&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ES6</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果在 index.js 中写一个箭头函数，当打包之后，在 bundle.js 中还是一个 ES6 的箭头函数，此时就需要 babel 的编译</span></span><br><span class="line"><span class="comment">// 需要安装 babel ：(@符号为组的意思)</span></span><br><span class="line"><span class="comment">// npm install @babel/core @babel/preset-env babel-loader -D --registry=https://registry.npm.taobao.org    </span></span><br><span class="line"><span class="comment">// 在根目录新建文件 .babelrc 文件，代码如下</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;presets&quot;</span>: [<span class="string">&quot;@babel/preset-env&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 module.exports 里面加入代码：</span></span><br><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">        &#123;</span><br><span class="line">            test: <span class="regexp">/\.js$/</span>, <span class="comment">// 只要是 .js 结尾的都走 babel-loader</span></span><br><span class="line">            loader: [<span class="string">&quot;babel-loader&quot;</span>],</span><br><span class="line">            include: path.join(__dirname, <span class="string">&quot;src&quot;</span>), <span class="comment">// 包含哪些目录需要走这个 loader</span></span><br><span class="line">            exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    ],</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// npm run dev 之后在 bundle.js 里面的箭头函数就会被转译为 ES5 语法</span></span><br></pre></td></tr></table></figure>



<h2 id="ES6-模块化"><a href="#ES6-模块化" class="headerlink" title="ES6 模块化"></a>ES6 模块化</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 刚才在上个文件的 src 目录下新建 a.js ,代码如下：</span></span><br><span class="line"><span class="comment">// 单个导出</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(fn)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> name = <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> obj = &#123;</span><br><span class="line">    name: <span class="string">&quot;zhangsan&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 一块导出简写</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;fn&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    name: <span class="string">&quot;zhangsan&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">exports</span> &#123;</span><br><span class="line">    fn, <span class="comment">// ES5 中需写成 fn: fn ,ES6 中 key 与 value 值一样则可省略 value</span></span><br><span class="line">    name,</span><br><span class="line">    obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后在 index.js 文件下的头部引入并输出）</span></span><br><span class="line"><span class="keyword">import</span> &#123; fn, name, obj &#125; <span class="keyword">from</span> <span class="string">&quot;./a&quot;</span>  <span class="comment">// 解构赋值</span></span><br><span class="line">fn()</span><br><span class="line"><span class="built_in">console</span>.log(name)</span><br><span class="line"><span class="built_in">console</span>.log(obj)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者，但是这种方法没办法用解构赋值，只能挨个导入</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    name: <span class="string">&quot;zs&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    obj,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="如何配置-webpack-生产环境"><a href="#如何配置-webpack-生产环境" class="headerlink" title="如何配置 webpack 生产环境"></a>如何配置 webpack 生产环境</h2><p>根目录下新建 webpack.prod.js （一共两个配置文件，一个开发环境下的，一个生产环境下的）</p>
<p><strong>1</strong>.可先复制一份 webpack.config.js 然后将里面的 mode 修改 production</p>
<p><strong>2</strong>.将 devServer 配置项全部删掉</p>
<p><strong>3</strong>.将 output 中的 filename 改为 “bundle.[contenthash].js”</p>
<p>  - 根据代码内容算出哈希的值，如果内容变了，这个哈希值也会跟着变，内容不变则不会变</p>
<p><strong>4</strong>.改 package.json 里面的 build ，之前默认的是启动服务，但此时不需要所以改变为 </p>
<p> - “build”: “webpack –config webpack.prod.js”</p>
<p>此时再次 npm run build</p>
<p>dist 文件夹下的 bundle.js 文件名称跟着长串字符（配置的 [contenthash] ），这个长串字符就是内容变则变，内容不变则不变</p>
<p>目地是最大程度命中 http 的缓存，让页面加载的更快</p>
<p>内容也是经过压缩，体积小、执行快、下载快</p>
<h2 id="Linux-命令"><a href="#Linux-命令" class="headerlink" title="Linux 命令"></a>Linux 命令</h2><ul>
<li>公司的线上机器一般都是 linux （参考阿里云）</li>
<li>测试机也要保持一致，用 linux</li>
<li>测试机或者线上机出了问题，本地有不能复现，需要去排查（非常常见）</li>
</ul>
<p><a href="https://www.runoob.com/linux/linux-command-manual.html">Linux 命令大全</a></p>
]]></content>
      <categories>
        <category>前端面试题</category>
      </categories>
      <tags>
        <tag>知识点总结</tag>
        <tag>前端开发环境</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面试题总结-第一阶段完成小结</title>
    <url>/2020/12/11/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%E5%AE%8C%E6%88%90%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<h1 id="知识体系思维导图"><a href="#知识体系思维导图" class="headerlink" title="知识体系思维导图"></a>知识体系思维导图</h1><a id="more"></a>

<img src="前端面试课-思维导图-知识体系.png" alt="前端面试课-思维导图-知识体系" style="zoom: 150%;" />

<h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><h2 id="HTML-面试题"><a href="#HTML-面试题" class="headerlink" title="HTML 面试题"></a>HTML 面试题</h2><ul>
<li>如何理解 HTML 语义化</li>
<li>默认情况下，哪些 HTML 标签是块级元素、哪些是內联元素</li>
</ul>
<h2 id="CSS-布局（1）"><a href="#CSS-布局（1）" class="headerlink" title="CSS - 布局（1）"></a>CSS - 布局（1）</h2><ul>
<li>盒子模型的宽度如何计算</li>
<li>margin 纵向重叠的问题</li>
<li>margin 负值的问题</li>
</ul>
<h2 id="CSS-布局（2）"><a href="#CSS-布局（2）" class="headerlink" title="CSS - 布局（2）"></a>CSS - 布局（2）</h2><ul>
<li>BFC 理解和应用</li>
<li>float 布局的问题，以及 clearfix </li>
<li>flex 画色子</li>
</ul>
<h2 id="CSS-定位"><a href="#CSS-定位" class="headerlink" title="CSS - 定位"></a>CSS - 定位</h2><ul>
<li>absolute 和 relative 分别依据什么定位</li>
<li>居中对齐有哪些实现方式</li>
</ul>
<h2 id="CSS-图文样式"><a href="#CSS-图文样式" class="headerlink" title="CSS - 图文样式"></a>CSS - 图文样式</h2><ul>
<li>line-height的继承问题</li>
</ul>
<h2 id="CSS-响应式"><a href="#CSS-响应式" class="headerlink" title="CSS - 响应式"></a>CSS - 响应式</h2><ul>
<li>rem 是什么</li>
<li>如何实现响应式</li>
</ul>
<h2 id="变量类型和计算"><a href="#变量类型和计算" class="headerlink" title="变量类型和计算"></a>变量类型和计算</h2><ul>
<li>typeof 能判断哪些类型</li>
<li>何时使用 === 何时使用 ==</li>
<li>值类型和引用类型的区别</li>
<li>手写深拷贝</li>
</ul>
<h2 id="原型和原型链"><a href="#原型和原型链" class="headerlink" title="原型和原型链"></a>原型和原型链</h2><ul>
<li>如何准确判断一个变量是不是数组</li>
<li>手写一个简易的 jQuery，考虑插件和扩展性</li>
<li>class 的原型本质，怎么理解</li>
</ul>
<h2 id="作用域和闭包"><a href="#作用域和闭包" class="headerlink" title="作用域和闭包"></a>作用域和闭包</h2><ul>
<li>this的不同应用场景，如何取值</li>
<li>手写bind函数</li>
<li>实际开发中闭包的应用场景，举例说明</li>
<li>循环定义生成十个 a 标签，弹出的 i 是多少</li>
</ul>
<h2 id="异步和单线程"><a href="#异步和单线程" class="headerlink" title="异步和单线程"></a>异步和单线程</h2><ul>
<li>同步和异步的区别是什么</li>
<li>手写用 Promise 加载一张图片</li>
<li>前端使用异步的场景有哪些</li>
<li>异步执行顺序问题</li>
</ul>
<h2 id="JS-异步进阶"><a href="#JS-异步进阶" class="headerlink" title="JS 异步进阶"></a>JS 异步进阶</h2><ul>
<li>请描述 event loop（事件循环/事件轮询）的机制，可画图</li>
<li>什么是宏任务和微任务，两者有什么区别</li>
<li>Promise 有哪三种状态？如何变化</li>
<li>promise、then 和 catch 的连接</li>
<li>async / await 的语法</li>
<li>promise 和 setTimeout 的顺序</li>
<li>外加 async / await 的顺序问题</li>
</ul>
<h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><ul>
<li>DOM 是哪种数据结构</li>
<li>DOM 操作的常用 API </li>
<li>attr 和 property 的区别</li>
<li>一次性插入多个 DOM 节点，考虑性能</li>
</ul>
<h2 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h2><ul>
<li>如何识别浏览器的类型</li>
<li>分析拆解 url 各个部分</li>
</ul>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><ul>
<li>编写一个通用的事件监听函数</li>
<li>描述事件冒泡的流程</li>
<li>无限下拉的图片列表，如何监听每个图片的点击</li>
</ul>
<h2 id="ajax"><a href="#ajax" class="headerlink" title="ajax"></a>ajax</h2><ul>
<li>手写一个简易的 ajax</li>
<li>跨域的常用实现方式</li>
</ul>
<h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><ul>
<li>描述 cookie、localStorage、sessionStorage 区别</li>
</ul>
<h2 id="页面加载过程"><a href="#页面加载过程" class="headerlink" title="页面加载过程"></a>页面加载过程</h2><ul>
<li>从输入 url 到渲染出页面的整个过程</li>
<li>window.onload 和 DOMContentloaded 的区别</li>
</ul>
<h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><ul>
<li>前端常见性能优化方案</li>
<li>手写节流和防抖（体验优化）</li>
</ul>
<h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><ul>
<li>Web 前端常见的安全攻击方式及预防</li>
</ul>
<h2 id="http"><a href="#http" class="headerlink" title="http"></a>http</h2><ul>
<li>http 常见的状态码有哪些</li>
<li>http 常见的 header 有哪些</li>
<li>什么是 Restful api</li>
<li>描述一下 http 的缓存机制（重要）</li>
</ul>
<h1 id="面试技巧"><a href="#面试技巧" class="headerlink" title="面试技巧"></a>面试技巧</h1><ul>
<li><p>关于简历</p>
<p>1.简洁明了，突出个人技能和项目经验</p>
<p>2.可以把个人博客、开源作品放在简历中（但博客要有内容）</p>
<p>3.不要造假，保证能力上的真实性（斟酌用词，如精通xxx，写了解，最多写个熟练）</p>
</li>
<li><p>面试过程中注意事项</p>
<p>1.如何看待加班：像借钱，救急不救穷</p>
<p>2.千万不要挑战面试官，反考面试官</p>
<p>3.学会给面试官惊喜，证明你能想到更多，做的更好，但不要太多</p>
<p>4.遇到不会的问题，说出你知道的部分即可，但别岔开话题</p>
<p>5.谈谈你的缺点：说一下你最近在学什么即可</p>
</li>
</ul>
]]></content>
      <categories>
        <category>前端面试题</category>
      </categories>
      <tags>
        <tag>知识点总结</tag>
        <tag>小结</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面试题总结-运行环境</title>
    <url>/2020/12/11/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93-%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<p>会了这些，就可以起飞…</p>
<ul>
<li>运行环境即浏览器（server 端有 nodejs）</li>
<li>下载网页代码，渲染出页面，期间会执行若干 JS</li>
<li>要保证代码在浏览器中：稳定且高效</li>
</ul>
<a id="more"></a>

<p>主要内容：</p>
<ul>
<li>网页加载过程</li>
<li>性能优化</li>
<li>安全</li>
</ul>
<h1 id="网页加载过程"><a href="#网页加载过程" class="headerlink" title="网页加载过程"></a>网页加载过程</h1><p>知识点</p>
<ul>
<li>加载资源的形式</li>
<li>加载资源的过程</li>
<li>渲染页面的过程</li>
</ul>
<h2 id="加载资源的形式"><a href="#加载资源的形式" class="headerlink" title="加载资源的形式"></a>加载资源的形式</h2><ul>
<li>html 代码</li>
<li>媒体文件，如图片、视频等</li>
<li>Javascript css</li>
</ul>
<h2 id="加载资源的过程"><a href="#加载资源的过程" class="headerlink" title="加载资源的过程"></a>加载资源的过程</h2><ul>
<li>DNS（Domain Name Server）解析∶域名 -&gt; IP 地址</li>
<li>浏览器根据 IP 地址向服务器发起 http 请求</li>
<li>服务器处理 http 请求，并返回给浏览器</li>
</ul>
<h2 id="渲染页面的过程-1"><a href="#渲染页面的过程-1" class="headerlink" title="渲染页面的过程-1"></a>渲染页面的过程-1</h2><ul>
<li>根据 HTML 代码生成 DOM Tree</li>
<li>根据 CSS 代码生成 CSSOM（CSS Object Module）</li>
<li>将 DOM Tree 和 CSSOM 整合形成 Render tree</li>
</ul>
<h2 id="渲染页面的过程-2"><a href="#渲染页面的过程-2" class="headerlink" title="渲染页面的过程-2"></a>渲染页面的过程-2</h2><ul>
<li><p>根据 Render tree 渲染页面</p>
</li>
<li><p>遇到 &lt;script&gt; 则暂停渲染，优先加载并执行 JS 代码，完成再继续</p>
<p><em>JS 线程与渲染线程共用一个线程，因为 JS 有可能会改变 DOM 结构，所以遇到 &lt;script&gt; 标签会暂停</em></p>
</li>
<li><p>直至把 Render tree 渲染完成</p>
</li>
</ul>
<p><strong>思考</strong></p>
<ul>
<li><p>为何建议把 css 放在 head 中？</p>
<p>是为了在 DOM tree 生成之前把 CSS 规则加载完，当 DOM tree 生成完之后，直接和所有的 CSS 规则整合生成一个渲染树，然后一步渲染完成，防止重复渲染</p>
</li>
<li><p>为何建议把 JS 放在 body 最后？</p>
<p>防止刚渲染出一部分，然后卡住并停止渲染，加载完 JS 之后又去渲染，会导致页面渲染时间比较长（例如本来期望应该页面的一共渲染时间为 1s，期望在 0.3 秒或者 0.5 秒之内让用户看到页面的所有内容，然后剩下时间再执行 JS 代码，最终把页面渲染完成，而不是直到最后一秒才让用户看到所有内容，所以要把 JS 放到最后）</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;load&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 页面的全部资源加载完成才会执行，包括图片、视频等</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&quot;DOMContentLoaded&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// DOM 渲染完成即可执行，此时图片、视频还可能没有加载完</span></span><br><span class="line">    <span class="comment">// 比较靠谱的选择</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul>
<li><p>从输入 url 到渲染出页面的整个过程</p>
<p>1.下载资源：各个资源类型，下载过程</p>
<p>2.渲染页面：结合 html css javascript 图片等</p>
</li>
<li><p>window.onload 与 DOMContentLoaded 区别</p>
<p>1.window. onload：资源全部加载完才能执行，包括图片</p>
<p>2.DOMContentLoaded：DOM 渲染完成即可，图片可能尚未下载</p>
</li>
</ul>
<h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><ul>
<li>是一个综合性问题，没有标准答案，但要求尽量全面</li>
<li>某些细节问题可能会单独提问：手写防抖、节流</li>
<li>只关注核心点，针对面试</li>
</ul>
<h2 id="性能优化原则"><a href="#性能优化原则" class="headerlink" title="性能优化原则"></a>性能优化原则</h2><ul>
<li>多使用内存、缓存或其他方法</li>
<li>减少 CPU 计算量，减少网络加载耗时</li>
<li>（适用于所有编程的性能优化 ：空间换时间）</li>
</ul>
<p><strong>从何入手</strong></p>
<h3 id="让加载更快"><a href="#让加载更快" class="headerlink" title="让加载更快"></a>让加载更快</h3><ul>
<li>减少资源体积：压缩代码</li>
<li>减少访问次数：合并代码、SSR 服务器端渲染、缓存、雪碧图</li>
<li>使用更快的网络：CDN（根据区域做服务器的处理，例如用 CDN 网络从北京访问的 IP 和从上海访问的 IP 是不一样的，根据区域联系运营商的服务器，让下载更快）</li>
</ul>
<h3 id="让渲染更快"><a href="#让渲染更快" class="headerlink" title="让渲染更快"></a>让渲染更快</h3><p><em>代码逻辑更合理，无无用功</em></p>
<p><strong>让渲染更快 1</strong></p>
<ul>
<li>CSS 放在 head，JS 放在 body 最下面</li>
<li>尽早开始执行 JS，用 DOMContentLoaded 触发</li>
<li>懒加载（图片懒加载，上滑加载更多）</li>
</ul>
<p><strong>让渲染更快 2</strong></p>
<ul>
<li>对 DOM 查询进行缓存</li>
<li>频繁 DOM 操作，合并到一起插入 DOM 结构</li>
<li>节流 throttle 防抖 debounce</li>
</ul>
<h2 id="前端性能优化的示例"><a href="#前端性能优化的示例" class="headerlink" title="前端性能优化的示例"></a>前端性能优化的示例</h2><ul>
<li><p>资源合并</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;a.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;b.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;c.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 这种方式更加合算，因为只有一次网络请求 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;abc.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> </span><br></pre></td></tr></table></figure>
</li>
<li><p>缓存</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    mode: <span class="string">&quot;production&quot;</span>,</span><br><span class="line">    entry: path.join(__dirname, <span class="string">&quot;src&quot;</span>, <span class="string">&quot;index&quot;</span>),</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">&quot;bundle.[contenthash].js&quot;</span>, <span class="comment">// 利用哈希对文件名处理</span></span><br><span class="line">        path: path.join(__idrname, <span class="string">&quot;dist&quot;</span>),</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 静态资源加 hash 后缀，根据文件内容计算 hash</span></span><br><span class="line"><span class="comment">// 文件内容不变，则 hash 不变，则 url 不变</span></span><br><span class="line"><span class="comment">// url 和文件不变，则会自动触发 http 缓存机制，返回 304</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>CDN</p>
<p>一般静态文件都是用 CDN 来做的，更大程度满足网络的性能</p>
<p><a href="https://www.zhihu.com/question/36514327">CDN是什么？使用CDN有什么优势？</a></p>
</li>
<li><p>SSR</p>
<p>服务器端渲染：将网页和数据一起加载，一起渲染</p>
<p>非 SSR（前后端分离）：先加载网页，再加载数据，再渲染数据</p>
<p>早先的 JSP、ASP、PHP，现在的 Vue、React、SSR、</p>
</li>
<li><p>懒加载</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">id</span>=<span class="string">&quot;img1&quot;</span> <span class="attr">src</span>=<span class="string">&quot;preview.png&quot;</span> <span class="attr">data-realsrc</span>=<span class="string">&quot;abc.png&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 当滑动到指定位置</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> img1 = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;img1&#x27;</span>)</span></span><br><span class="line"><span class="javascript">    img1.src = img1.getAttribute(<span class="string">&#x27;data-realsrc&#x27;</span>)</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>缓存 DOM 查询</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不缓存 DOM 查询结果</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;p&quot;</span>).length; i++) &#123;</span><br><span class="line">    <span class="comment">// 每次循环，都会计算 length，频繁进行 DOM 查询</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 缓存 DOM 查询结果</span></span><br><span class="line"><span class="keyword">const</span> pList = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;p&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> length = pList.length</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="comment">// 缓存 length，只进行一次 DOM 查询</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>多个 DOM 操作一起插入到 DOM 结构</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> listNode = <span class="built_in">document</span>.getElementById(<span class="string">&quot;list&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个文档片段，此时还没有插入到 DOM 树中</span></span><br><span class="line"><span class="keyword">const</span> frag = <span class="built_in">document</span>.createDocumentFragment()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行插入</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x = <span class="number">0</span>; x &lt; <span class="number">10</span>; x++) &#123;</span><br><span class="line">    <span class="keyword">const</span> li = <span class="built_in">document</span>.createElement(<span class="string">&quot;li&quot;</span>)</span><br><span class="line">    li.innerHTML = <span class="string">&quot;List item &quot;</span> + x</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 先插入文档片段中</span></span><br><span class="line">    frag.appendChild(li)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 都完成之后，再统一插入到 DOM 树中</span></span><br><span class="line">listNode.appendChild(frag)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也就是说，先建一个临时区域，把所有的高频操作都在临时区域中去插入</span></span><br><span class="line"><span class="comment">// 插入完成之后，再把临时区域一块放在 DOM 结构中，这样性能就会大大提升</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<h1 id="防抖-debounce"><a href="#防抖-debounce" class="headerlink" title="防抖 debounce"></a>防抖 debounce</h1><ul>
<li>监听一个输入框的，文字变化后触发 change 事件</li>
<li>直接用 keyup 事件，则会频发触发 change 事件</li>
<li>防抖：用户输入结束或暂停时，才会触发 change 事件</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模拟未做防抖场景</span></span><br><span class="line"><span class="comment">// html 中有一个输入框 &lt;input type=&quot;text&quot; id=&quot;ipt1&quot;&gt;</span></span><br><span class="line"><span class="comment">// js 代码如下</span></span><br><span class="line"><span class="keyword">var</span> ipt = <span class="built_in">document</span>.getElementById(<span class="string">&quot;ipt1&quot;</span>)</span><br><span class="line">ipt.addEventListener(<span class="string">&quot;keyup&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(ipt.value) <span class="comment">// 频繁触发请求很糟糕</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 做防抖改造</span></span><br><span class="line"><span class="keyword">var</span> ipt = <span class="built_in">document</span>.getElementById(<span class="string">&quot;ipt1&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">ipt.addEventListener(<span class="string">&quot;keyup&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">    &#125;</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(ipt.value) <span class="comment">// 模拟触发 change 事件</span></span><br><span class="line"></span><br><span class="line">        timer = <span class="literal">null</span> <span class="comment">// 清空定时器</span></span><br><span class="line">    &#125;, <span class="number">300</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 封装 debounce 函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay = <span class="number">300</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// timer 是在闭包中的</span></span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 闭包一般是用在函数作为返回值或者函数作为参数传入</span></span><br><span class="line">    <span class="comment">// 因此需要闭包</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">            <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">        &#125;</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            fn()</span><br><span class="line">            timer = <span class="literal">null</span></span><br><span class="line">        &#125;, delay);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ipt = <span class="built_in">document</span>.getElementById(<span class="string">&quot;ipt1&quot;</span>)</span><br><span class="line">ipt.addEventListener(<span class="string">&#x27;keyup&#x27;</span>, debounce(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(ipt.value)</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure>

<h1 id="节流-throttle"><a href="#节流-throttle" class="headerlink" title="节流 throttle"></a>节流 throttle</h1><p>频繁操作、频繁输入的时候会保持一个频率连续触发</p>
<ul>
<li>拖拽一个元素时，要随时拿到该元素被拖拽的位置</li>
<li>直接用 drag 事件，则会频发触发，很容易导致卡顿</li>
<li>节流：无论拖拽速度多快，都会每隔 100ms 触发一次</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代码示例</span></span><br><span class="line"><span class="comment">// html 片段</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">&lt;style&gt;</span></span><br><span class="line"><span class="comment">    #div1 &#123;</span></span><br><span class="line"><span class="comment">        border: 1px solid #ccc;</span></span><br><span class="line"><span class="comment">        width: 200px;</span></span><br><span class="line"><span class="comment">        height: 100px;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&lt;/style&gt; </span></span><br><span class="line"><span class="comment">&lt;body&gt;</span></span><br><span class="line"><span class="comment">    &lt;div id=&quot;div1&quot; draggable=&quot;true&quot;&gt;可拖拽&lt;/div&gt;</span></span><br><span class="line"><span class="comment">&lt;/body&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// js code</span></span><br><span class="line"><span class="keyword">const</span> div1 = <span class="built_in">document</span>.getElementById(<span class="string">&quot;div1&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">div1.addEventListener(<span class="string">&quot;drag&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (timer) <span class="keyword">return</span></span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(e.offsetX, e.offsetY)</span><br><span class="line"></span><br><span class="line">        timer = <span class="literal">null</span></span><br><span class="line">    &#125;, <span class="number">100</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 封装 throttle 函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, delay = <span class="number">100</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (timer) <span class="keyword">return</span></span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 此处的 apply 方法后面的 arguments 对于 e 有用</span></span><br><span class="line">            fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">            timer = <span class="literal">null</span></span><br><span class="line">        &#125;, delay)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 或者不用 apply</span></span><br><span class="line">    <span class="comment">// return function (e) &#123;</span></span><br><span class="line">    <span class="comment">//     if (timer) return</span></span><br><span class="line">    <span class="comment">//     timer = setTimeout(() =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//         fn(e)</span></span><br><span class="line">    <span class="comment">//         timer = null</span></span><br><span class="line">    <span class="comment">//     &#125;, delay)</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> div1 = <span class="built_in">document</span>.getElementById(<span class="string">&quot;div1&quot;</span>)</span><br><span class="line">div1.addEventListener(<span class="string">&quot;drag&quot;</span>, throttle(<span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    	<span class="comment">// 这里面的 e 不会直接传递给函数里面</span></span><br><span class="line">    	<span class="comment">// 而是先传递到上面返回的函数里面</span></span><br><span class="line">    	<span class="comment">// 因此有必要在上面返回函数中的 fn 加上 apply(this, arguments)</span></span><br><span class="line">    	<span class="comment">// 这样函数里面才能接收到 e</span></span><br><span class="line">        <span class="built_in">console</span>.log(e.offsetX, e.offsetY)</span><br><span class="line">    &#125;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h1><p>问题：</p>
<p>常见的 web 前端攻击方式有哪些？</p>
<h2 id="XSS-跨站请求攻击"><a href="#XSS-跨站请求攻击" class="headerlink" title="XSS 跨站请求攻击"></a>XSS 跨站请求攻击</h2><ul>
<li><p>个博客网站，我发表一篇博客，其中嵌入 &lt;script&gt; 脚本</p>
</li>
<li><p>脚本内容：获取 cookie，发送到我的服务器（服务器配合跨域）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- html code --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span> 一段内容 <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">alert(<span class="string">&quot;document.cookie&quot;</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>发布这篇博客，有人查看它，我轻松收割访问者的 cookie</p>
</li>
</ul>
<p><strong>XSS 预防</strong></p>
<ul>
<li><p>替换特殊字符，如 &lt; 变成 &amp;lt； &gt; 变成 &amp;gt;</p>
</li>
<li><p>&lt;script&gt;变成 &amp;lt;script&amp;gt; , 直接显示，而不会作为脚本执行</p>
</li>
<li><p>前端要替换，后端也要替换，都做总不会有错</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- html code --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span> 一段内容 <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="symbol">&amp;lt;</span>script<span class="symbol">&amp;gt;</span>alert(document.cookie);<span class="symbol">&amp;lt;</span>/script<span class="symbol">&amp;gt;</span></span><br></pre></td></tr></table></figure>

<p><a href="https://www.npmjs.com/package/xss">https://www.npmjs.com/package/xss</a></p>
</li>
</ul>
<h2 id="XSRF-跨站请求伪造"><a href="#XSRF-跨站请求伪造" class="headerlink" title="XSRF 跨站请求伪造"></a>XSRF 跨站请求伪造</h2><p>场景</p>
<ul>
<li>你正在购物，看中了某个商品，商品 id 是 100</li>
<li>付费接口是 xxx.com/pay?id=100，但没有任何验证</li>
<li>我是攻击者，我看中了一个商品，id是 200</li>
</ul>
<p>请求伪造</p>
<ul>
<li>我向你发送一封电子邮件，邮件标题很吸引人</li>
<li>但邮件正文隐藏着 &lt;img src=xxx.com/pay?id=200/&gt;</li>
<li>你一查看邮件，就帮我购买了 id 是 200 的商品</li>
</ul>
<p>XSRF 预防</p>
<ul>
<li>使用 post 接口（用这种方法，再用 img 或其他就无法攻击，post 接口做跨域很麻烦，需要 server 支持）</li>
<li>增加验证，例如密码、短信验证码、指纹等</li>
</ul>
]]></content>
      <categories>
        <category>前端面试题</category>
      </categories>
      <tags>
        <tag>知识点总结</tag>
        <tag>前端运行环境</tag>
      </tags>
  </entry>
  <entry>
    <title>将hexo博客部署到github或gitee</title>
    <url>/2020/11/18/%E5%B0%86hexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%88%B0github%E6%88%96gitee/</url>
    <content><![CDATA[<p>使用github/gitee pages服务搭建博客的好处有： </p>
<ul>
<li>全是静态文件，访问速度快；</li>
<li>免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台；</li>
<li>可以绑定自己的域名；</li>
<li>数据安全，基于github的版本管理，想恢复到哪个历史版本都行；</li>
<li>博客内容可以轻松打包、转移、发布到其它平台；</li>
<li>= =</li>
</ul>
<a id="more"></a>

<h1 id="部署到远端"><a href="#部署到远端" class="headerlink" title="部署到远端"></a>部署到远端</h1><h2 id="github部署的方式"><a href="#github部署的方式" class="headerlink" title="github部署的方式"></a>github部署的方式</h2><ul>
<li>优点：部署比较简单，且不用频繁的更新部署</li>
<li>缺点：访问速度相对于gitee较慢，每次hexo d比较慢。</li>
</ul>
<p>登录github后，点击右上角的＋，然后点击new repository</p>
<p><img src="newrepository.jpg"></p>
<p>说明：下面这张图片中出现红色是因为我之前已经用这个地址申请过一个仓库，波浪线处尽量与前面的名字一样，后面的.github.io固定。然后拉到底部点击create repository</p>
<p><img src="newsave.jpg"></p>
<p><img src="%E9%83%A8%E7%BD%B211.jpg"></p>
<p>复制仓库地址后后打开站点配置文件，找到deploy字段，按下图操作。</p>
<p><img src="%E9%83%A8%E7%BD%B2222.jpg"></p>
<p>此时我们需要在博客根目录下打开命令行，装一个部署git的插件(已经切换到淘宝镜像源的可用cnpm命令)</p>
<p>npm install –save hexo-deployer-git</p>
<p>插件安装完成后，可以通过命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<p> 就可以部署到github，此时打开仓库就会有内容了。</p>
<p>直接把你的网址中下面图片中蓝色部分拿出来，输入到浏览器中即可访问你的静态博客页面。</p>
<p><img src="%E8%AE%BF%E9%97%AE11.jpg"></p>
<p>注：1. 刷新不出博客页面稍等两分钟即可   2.每次部署可以：hexo d -m “提交的说明”</p>
<h2 id="gitee（码云）部署到远端"><a href="#gitee（码云）部署到远端" class="headerlink" title="gitee（码云）部署到远端"></a>gitee（码云）部署到远端</h2><ul>
<li>优点：访问速度快，中文页面友好</li>
<li>缺点：每次部署后都需要服务中点击更新部署</li>
</ul>
<p>与github部署方式大同小异，登录gitee后点击右上角的加号，新建仓库</p>
<p><img src="gitee%E4%BB%93%E5%BA%93%E5%88%9B%E5%BB%BA.jpg"></p>
<p>仓库建好后，复制仓库地址到站点配置文件_config.yml中</p>
<p><img src="gitee%E9%83%A8%E7%BD%B2%E5%90%8E%E7%AB%99%E7%82%B9%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.jpg"></p>
<p>此时我们需要在博客根目录下打开命令行，装一个部署git的插件(已经切换到淘宝镜像源的可用cnpm命令)</p>
<p>npm install –save hexo-deployer-git</p>
<p>插件安装完成后，可以通过命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<p>命令执行完毕后，刷新仓库页面，此时仓库就会有内容，点击仓库的服务</p>
<p><img src="gitee%E6%9C%8D%E5%8A%A1.jpg"></p>
<p><img src="gitee%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1.jpg"></p>
<p><img src="gitee%E9%83%A8%E7%BD%B2%E5%AE%8C%E6%88%90.jpg"></p>
<p>这个地址就是你的个人静态博客地址，也可以打开博客部署到的仓库查看地址，点击可直接访问。</p>
<p><img src="MyblogAdress.jpg"></p>
<p>注意：每次执行完命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo d -m &quot;提交说明&quot; </span><br></pre></td></tr></table></figure>

<p>需要到仓库服务中点开Gitee Pages，然后点击更新等一两分钟才能更新静态博客。</p>
<p> 如果有什么问题或者技术交流，欢迎在下方发布渠道二维码联系我或者文章底部留言。 </p>
]]></content>
      <categories>
        <category>从0搭建博客及美化</category>
      </categories>
      <tags>
        <tag>部署博客到远端</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面试题总结-HTML&amp;CSS部分</title>
    <url>/2020/11/22/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93-HTML&amp;CSS%E9%83%A8%E5%88%86/</url>
    <content><![CDATA[<p><strong>下面内容包括一些常考的、重要的HTML&amp;CSS前端面试题， 是必考知识，不过关直接回家的那种</strong></p>
<h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><h2 id="如何理解HTML语义化？"><a href="#如何理解HTML语义化？" class="headerlink" title="如何理解HTML语义化？"></a>如何理解HTML语义化？</h2><ul>
<li><strong>让人更容易读懂（增加代码可读性）</strong></li>
<li><strong>让搜索引擎更容易读懂（SEO）</strong></li>
</ul>
<h2 id="块状元素-amp-内联元素？"><a href="#块状元素-amp-内联元素？" class="headerlink" title="块状元素&amp;内联元素？"></a>块状元素&amp;内联元素？</h2><a id="more"></a>

<p>display:block/ table；有div、h1、h2、table、ul、ol、p等<br>display:inline/ inline- block；有 span、img、input、button等</p>
<h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h2 id="CSS-布局"><a href="#CSS-布局" class="headerlink" title="CSS-布局"></a>CSS-布局</h2><h3 id="盒模型宽度计算"><a href="#盒模型宽度计算" class="headerlink" title="盒模型宽度计算"></a>盒模型宽度计算</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="comment">/* 如下代码，请问div1的 offsetwidth是多大？ */</span></span></span><br><span class="line"><span class="css">    <span class="selector-id">#div1</span> &#123;</span></span><br><span class="line">        width: 100px;</span><br><span class="line">        padding: 10px;</span><br><span class="line"><span class="css">        <span class="selector-tag">border</span>: 1<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#ccc</span>;</span></span><br><span class="line">        margin: 10px;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>offsetwidth =（内容宽度+内边距+边框），无外边距</p>
<p>因此答案是122px</p>
<p>补充：如果让 offsetwidth等于100px，该如何做？</p>
<p>在标签选择器中添加下面一行代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">box-sizing: border-box;</span><br></pre></td></tr></table></figure>

<p>也就是说，这个时候为这个标签设置宽度的时候是包括内容、内边距、边框的。</p>
<h3 id="margin纵向重叠问题"><a href="#margin纵向重叠问题" class="headerlink" title="margin纵向重叠问题"></a>margin纵向重叠问题</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="comment">/* 如下代码，AAA和BBB之间的距离是多少 */</span></span></span><br><span class="line">    p &#123;</span><br><span class="line">        font-size: 16px;</span><br><span class="line">        line-height: 1;</span><br><span class="line">        margin-top: 10px;</span><br><span class="line">        margin-bottom: 15px;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>AAA<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>BBB<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>相邻元素的 margin-top和 margin-bottom会发生重叠<br>空白内容的p标签也会重叠<br>答案：15px</p>
<h3 id="margin负值问题"><a href="#margin负值问题" class="headerlink" title="margin负值问题"></a>margin负值问题</h3><ul>
<li>margin-top和margin-left负值，元素向上、向左移动</li>
<li>margin- right负值，右侧元素左移，自身不受影响</li>
<li>margin-bottom负值，下方元素上移，自身不受影响</li>
</ul>
<h3 id="BFC理解与应用"><a href="#BFC理解与应用" class="headerlink" title="BFC理解与应用"></a>BFC理解与应用</h3><ul>
<li>Block format context，块级格式化上下文</li>
<li>一块独立渲染区域，内部元素的渲染不会影响边界以外的元素</li>
</ul>
<p>形成BFC的常见条件</p>
<ul>
<li>float不是none</li>
<li>position是absolute或fixed</li>
<li>overflow不是visible</li>
<li>display是 flex、inline-block等</li>
</ul>
<p>BFC的常见应用</p>
<p>清除浮动</p>
<p>如下代码所示，此时从图片中可以看出来格式是完全乱的，文字也会贯穿到左侧，这是由于img设置了float后跑出了这个容器之内，这就是我们所说的脱离文档流，这对我们的布局是一个很大的问题，此时我们就可以通过BFC来解决这个问题。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="comment">/* 如下代码，AAA和BBB之间的距离是多少 */</span></span></span><br><span class="line"><span class="css">    <span class="selector-class">.container</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">background-color</span>: <span class="selector-id">#f1f1f1</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-class">.left</span> &#123;</span></span><br><span class="line">        float: left;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="css">    <span class="selector-class">.bfc</span> &#123;</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container bfc&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://cn.vuejs.org/images/logo.png&quot;</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span> <span class="attr">style</span>=<span class="string">&quot;magin-right: 10px; width: 10%;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;bfc&quot;</span>&gt;</span>某一段文字……<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="1605790802753.png" alt="1605790802753"></p>
<p>在style中加入这一行（参见形成BFC的常见条件，其中有一项就是overflow不是visible）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">.bfc &#123;</span><br><span class="line">        overflow: hidden;  /* 触发元素 BFC */</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这个时候容器就会被这个图片撑高了，并且文字也不会贯穿到左侧。</p>
<p><img src="1605790776904.png" alt="1605790776904"></p>
<p>总结：BFC的核心用意是-他是一个独立渲染区域，它内部的区域怎么去渲染都不会影响到外部。</p>
<p>（通过这个容器案例有一个很直观的体验，如果这个容器没有BFC的话，图片会跑出去，如果有BFC的话，即便是img浮动，也不会跑出这个容器，而是会把这个容器撑大；文字之所以加BFC，是因为如果img浮动，那么img的位子将不复存在，因此文字一行会贯穿到左侧，所以需要给它加一个BFC。注：即使img设置浮动，但是文字不会占据浮动标签的位置，只会环绕周围，而其左侧会被p标签的空白填满。）</p>
<h3 id="float布局"><a href="#float布局" class="headerlink" title="float布局"></a>float布局</h3><ul>
<li>如何实现圣杯布局和双飞翼布局</li>
<li>手写 clearfix</li>
</ul>
<p><strong>圣杯布局和双飞翼布局的目的</strong></p>
<ul>
<li>三栏布局，中间一栏最先加载和渲染（内容最重要）</li>
<li>两侧内容固定，中间内容随着宽度自适应</li>
<li>一般用于PC网页</li>
</ul>
<p><strong>圣杯布局和双飞翼布局的技术总结</strong></p>
<ul>
<li>使用 float布局</li>
<li>两侧使用 margin负值，以便和中间内容横向重叠</li>
<li>防止中间内容被两侧覆盖，一个用 padding一个用 margin</li>
</ul>
<p>两侧使用margin负值，为了让两侧与中间内容横向重叠</p>
<p>一种方法用padding一种方法用margin，两种实现的实现的方法，大同小异</p>
<p>圣杯布局是通过<strong>父级元素padding</strong>两边留白的（中间的center的width是100%撑满的，并且希望它居中的，因此需要给父元素设置一个内边距padding，这样才能满足虽然center是100%，但是它也是居中的，左边右边都可以有内容，因此根据左右元素的width设置padding）</p>
<p>双飞翼布局是通过<strong>子元素margin</strong>两边留白的</p>
<p>两种方法最终都是相当于包裹在了一个大的父元素里面。</p>
<h4 id="圣杯布局"><a href="#圣杯布局" class="headerlink" title="圣杯布局"></a>圣杯布局</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    html,</span><br><span class="line">    body &#123;</span><br><span class="line">        min-width: 600px;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    header,</span><br><span class="line">    footer &#123;</span><br><span class="line">        text-align: center;</span><br><span class="line">        font-size: 16px;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-id">#center</span> &#123;</span></span><br><span class="line">        background-color: blue;</span><br><span class="line">        width: 100%;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-id">#left</span> &#123;</span></span><br><span class="line">        position: relative;</span><br><span class="line">        background-color: green;</span><br><span class="line">        width: 200px;</span><br><span class="line">        margin-left: -100%;</span><br><span class="line">        right: 200px;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-id">#right</span> &#123;</span></span><br><span class="line">        background-color: pink;</span><br><span class="line">        width: 150px;</span><br><span class="line">        margin-right: -150px;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-id">#container</span> &#123;</span></span><br><span class="line">        padding-left: 200px;</span><br><span class="line">        padding-right: 150px;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-class">.column</span> &#123;</span></span><br><span class="line">        float: left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    footer &#123;</span><br><span class="line">        clear: both;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">header</span>&gt;</span>this is header<span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;center&quot;</span> <span class="attr">class</span>=<span class="string">&quot;column&quot;</span>&gt;</span>this is content<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;left&quot;</span> <span class="attr">class</span>=<span class="string">&quot;column&quot;</span>&gt;</span>this is left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;right&quot;</span> <span class="attr">class</span>=<span class="string">&quot;column&quot;</span>&gt;</span>this is right<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">footer</span>&gt;</span>this is footer<span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="双飞翼布局"><a href="#双飞翼布局" class="headerlink" title="双飞翼布局"></a>双飞翼布局</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    html,</span><br><span class="line">    body &#123;</span><br><span class="line">        min-width: 600px;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-id">#main</span> &#123;</span></span><br><span class="line">        width: 100%;</span><br><span class="line">        height: 200px;</span><br><span class="line">        background-color: grey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-id">#left</span> &#123;</span></span><br><span class="line">        width: 190px;</span><br><span class="line">        height: 200px;</span><br><span class="line"><span class="css">        <span class="selector-tag">background-color</span>: <span class="selector-id">#0000FF</span>;</span></span><br><span class="line">        margin-left: -100%;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-id">#right</span> &#123;</span></span><br><span class="line">        width: 190px;</span><br><span class="line">        height: 200px;</span><br><span class="line"><span class="css">        <span class="selector-tag">background-color</span>: <span class="selector-id">#FF0000</span>;</span></span><br><span class="line">        margin-left: -190px;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-class">.col</span> &#123;</span></span><br><span class="line">        float: left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-id">#main-wrap</span> &#123;</span></span><br><span class="line">        margin: 0 190px 0 190px;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;main&quot;</span> <span class="attr">class</span>=<span class="string">&quot;col&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;main-wrap&quot;</span>&gt;</span></span><br><span class="line">        this is main</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;left&quot;</span> <span class="attr">class</span>=<span class="string">&quot;col&quot;</span>&gt;</span></span><br><span class="line">    this is left</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;right&quot;</span> <span class="attr">class</span>=<span class="string">&quot;col&quot;</span>&gt;</span></span><br><span class="line">    this is right</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="手写clearfix"><a href="#手写clearfix" class="headerlink" title="手写clearfix"></a>手写clearfix</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">.clearfix:after &#123;</span><br><span class="line">	content: &#x27;&#x27;;</span><br><span class="line">	display: table; /* display: block; 也可以 */</span><br><span class="line">	clear: both</span><br><span class="line">&#125;</span><br><span class="line">.clearfix: &#123;</span><br><span class="line">	*zoom: 1;  /* 兼容 IE 低版本浏览器 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h3><p>常用语法回顾</p>
<ul>
<li>flex- direction</li>
<li>justify- content</li>
<li>align-items</li>
<li>flex-wrap</li>
<li>align-self </li>
</ul>
<p><strong>这几条一定要掌握并且会用！</strong></p>
<h4 id="flex-画色子"><a href="#flex-画色子" class="headerlink" title="flex-画色子"></a>flex-画色子</h4><h5 id="一点"><a href="#一点" class="headerlink" title="一点"></a>一点</h5><p><em>注：lex布局，设置主轴与侧轴位置水平即可</em></p>
<p><img src="1606024006006.png" alt="1606024006006"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.box</span> &#123;</span></span><br><span class="line">        width: 200px;</span><br><span class="line">        height: 200px;</span><br><span class="line">        border: 2px solid gray;</span><br><span class="line">        border-radius: 5px;</span><br><span class="line">        margin: auto;</span><br><span class="line"></span><br><span class="line">        display: flex;</span><br><span class="line">        justify-content: center;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-class">.item1</span> &#123;</span></span><br><span class="line">        width: 40px;</span><br><span class="line">        height: 40px;</span><br><span class="line">        border-radius: 50%;</span><br><span class="line">        background-color: gray;</span><br><span class="line"></span><br><span class="line">        align-self: center;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="二点"><a href="#二点" class="headerlink" title="二点"></a>二点</h5><p><em>注：flex布局，设置主轴方向为列，主轴两端对齐+侧轴居中</em></p>
<p><img src="1606026525191.png" alt="1606026525191"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.box</span> &#123;</span></span><br><span class="line">        width: 200px;</span><br><span class="line">        height: 200px;</span><br><span class="line">        border: 2px solid gray;</span><br><span class="line">        border-radius: 5px;</span><br><span class="line">        margin: auto;</span><br><span class="line"></span><br><span class="line">        display: flex;</span><br><span class="line">        flex-direction: column;</span><br><span class="line">        justify-content: space-between;</span><br><span class="line">        align-items: center;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-class">.item</span> &#123;</span></span><br><span class="line">        width: 40px;</span><br><span class="line">        height: 40px;</span><br><span class="line">        border-radius: 50%;</span><br><span class="line">        background-color: gray;</span><br><span class="line">        margin: 15px;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="三点"><a href="#三点" class="headerlink" title="三点"></a>三点</h5><p><em>注：flex布局，两端对齐后，第二个点侧轴居中，第三个点侧轴底对齐</em></p>
<p><img src="1606025489313.png" alt="1606025489313"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.box</span> &#123;</span></span><br><span class="line">        width: 200px;</span><br><span class="line">        height: 200px;</span><br><span class="line"><span class="css">        <span class="selector-tag">border</span>: 2<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#ccc</span>;</span></span><br><span class="line">        border-radius: 10px;</span><br><span class="line">        padding: 20px;</span><br><span class="line"></span><br><span class="line">        display: flex;</span><br><span class="line">        justify-content: space-between;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-class">.item</span> &#123;</span></span><br><span class="line">        display: block;</span><br><span class="line">        width: 40px;</span><br><span class="line">        height: 40px;</span><br><span class="line">        border-radius: 50%;</span><br><span class="line"><span class="css">        <span class="selector-tag">background-color</span>: <span class="selector-id">#666</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-class">.item</span><span class="selector-pseudo">:nth-child(2)</span> &#123;</span></span><br><span class="line">        align-self: center;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-class">.item</span><span class="selector-pseudo">:nth-child(3)</span> &#123;</span></span><br><span class="line">        align-self: flex-end;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="四点"><a href="#四点" class="headerlink" title="四点"></a>四点</h5><p><img src="1606027896364.png" alt="1606027896364"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.html</span>,</span></span><br><span class="line">    body &#123;</span><br><span class="line">        min-width: 600px;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-class">.box</span> &#123;</span></span><br><span class="line">        width: 200px;</span><br><span class="line">        height: 200px;</span><br><span class="line">        border: 2px solid gray;</span><br><span class="line">        border-radius: 5px;</span><br><span class="line">        margin: auto;</span><br><span class="line"></span><br><span class="line">        display: flex;</span><br><span class="line">        flex-wrap: wrap;</span><br><span class="line">        justify-content: space-around;</span><br><span class="line">        align-content: space-around;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-class">.item</span> &#123;</span></span><br><span class="line">        width: 40px;</span><br><span class="line">        height: 40px;</span><br><span class="line">        border-radius: 50%;</span><br><span class="line">        background-color: gray;</span><br><span class="line"><span class="css">        <span class="selector-tag">margin</span>: 15<span class="selector-tag">px</span>; <span class="comment">/* 起到撑开色子间距并换行 */</span></span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="五点"><a href="#五点" class="headerlink" title="五点"></a>五点</h5><p><img src="1606028492611.png" alt="1606028492611"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.html</span>,</span></span><br><span class="line">    body &#123;</span><br><span class="line">        min-width: 600px;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-class">.box</span> &#123;</span></span><br><span class="line">        width: 200px;</span><br><span class="line">        height: 200px;</span><br><span class="line">        border: 2px solid gray;</span><br><span class="line">        border-radius: 5px;</span><br><span class="line">        margin: auto;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-class">.top</span>,</span></span><br><span class="line"><span class="css">    <span class="selector-class">.bottom</span> &#123;</span></span><br><span class="line">        display: flex;</span><br><span class="line">        justify-content: space-between;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-class">.item</span> &#123;</span></span><br><span class="line">        width: 40px;</span><br><span class="line">        height: 40px;</span><br><span class="line">        border-radius: 50%;</span><br><span class="line">        background-color: gray;</span><br><span class="line">        margin: 15px;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-class">.center</span> <span class="selector-class">.item</span> &#123;</span></span><br><span class="line">        margin: 10px auto 10px;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;top&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;center&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;bottom&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="六点"><a href="#六点" class="headerlink" title="六点"></a>六点</h5><p><img src="1606028760622.png" alt="1606028760622"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.html</span>,</span></span><br><span class="line">    body &#123;</span><br><span class="line">        min-width: 600px;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-class">.box</span> &#123;</span></span><br><span class="line">        width: 200px;</span><br><span class="line">        height: 200px;</span><br><span class="line">        border: 2px solid gray;</span><br><span class="line">        border-radius: 5px;</span><br><span class="line">        margin: auto;</span><br><span class="line"></span><br><span class="line">        display: flex;</span><br><span class="line">        flex-wrap: wrap;</span><br><span class="line">        justify-content: space-between;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-class">.item</span> &#123;</span></span><br><span class="line">        width: 40px;</span><br><span class="line">        height: 40px;</span><br><span class="line">        border-radius: 50%;</span><br><span class="line">        background-color: gray;</span><br><span class="line">        margin: 15px 15px 0;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p> align-items在伸缩容器上使用它，伸缩容器内部所有的元素都一致地受制于align-items的值。 但是有些时候，我们希望伸缩容器内部某个元素在侧轴上的排列方式有所差异。此时就不能使用 align-items，因为align-items作用于整体。我们希望作用于部分。这就是align-self的发挥场地。 </p>
<p>注：align-items 为弹性容器中所有项目设置缺省对齐属性，包括匿名弹性项目。</p>
<p>​       align-self 可以为单独的弹性项目设置对齐来覆盖缺省值。</p>
<h2 id="CSS-定位"><a href="#CSS-定位" class="headerlink" title="CSS-定位"></a>CSS-定位</h2><h3 id="absolute和-relative分别依据什么定位？"><a href="#absolute和-relative分别依据什么定位？" class="headerlink" title="absolute和 relative分别依据什么定位？"></a>absolute和 relative分别依据什么定位？</h3><p>不论面试还是开发中非常重要的问题！</p>
<p>relative 依据自身定位，并且对外界元素没任何影响<br>absolute 依据最近一层的定位元素（absolute、relative、fixed）定位，一直往上找父元素，如果实在没有定位元素，那么最后就是依据body</p>
<h3 id="居中对齐有哪些实现方式？"><a href="#居中对齐有哪些实现方式？" class="headerlink" title="居中对齐有哪些实现方式？"></a>居中对齐有哪些实现方式？</h3><p>CSS面试中90%会考的题目！</p>
<p><strong>水平居中</strong></p>
<p>inline元素：text- align:center<br>bock元素：margin:auto<br>absolute元素：left：50% + margin-left负值</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.container</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">border</span>: 1<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#ccc</span>;</span></span><br><span class="line">        margin: 10px;</span><br><span class="line">        padding: 10px;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.item</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">background-color</span>: <span class="selector-id">#ccc</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line"><span class="css">    <span class="comment">/* 第一种 */</span></span></span><br><span class="line"><span class="css">    <span class="selector-class">.container-1</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">text-align</span>: <span class="selector-tag">center</span>; <span class="comment">/* 内部的行内元素实现行内元素水平居中 */</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="comment">/* 第二种 */</span></span></span><br><span class="line"><span class="css">    <span class="selector-class">.container-2</span> <span class="selector-class">.item</span> &#123;</span></span><br><span class="line">        width: 500px;</span><br><span class="line"><span class="css">        <span class="selector-tag">margin</span>: <span class="selector-tag">auto</span>;  <span class="comment">/* 左右边自动填充实现内部块级元素的水平居中 */</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="comment">/* 第三种 */</span></span></span><br><span class="line"><span class="css">    <span class="selector-class">.container-3</span> &#123;</span></span><br><span class="line">        position: relative;</span><br><span class="line">        height: 100px;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.container-3</span> <span class="selector-class">.item</span> &#123;</span></span><br><span class="line">        width: 300px;</span><br><span class="line">        height: 100px;</span><br><span class="line"><span class="css">        <span class="selector-tag">position</span>: <span class="selector-tag">absolute</span>; <span class="comment">/* 子绝父相实现水平居中 */</span></span></span><br><span class="line">        left: 50%;</span><br><span class="line">        margin-left: -150px;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container container-1&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>一段文字<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container container-2&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span></span><br><span class="line">            this is block item</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container container-3&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span></span><br><span class="line">            this is absolute item</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>垂直居中</strong></p>
<p>inline 元素：line-height的值等于 height值<br>absolute 元素：top：50% + margin-top负值<br>absolute 元素：transform（-50%，-50%）<br>absolute 元素:top、left、bottom、right = 0 最后加一个 margin:auto</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.container</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">border</span>: 1<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#ccc</span>;</span></span><br><span class="line">        margin: 10px;</span><br><span class="line">        padding: 10px;</span><br><span class="line">        height: 200px;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.item</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">background-color</span>: <span class="selector-id">#ccc</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="comment">/* 第一种 */</span></span></span><br><span class="line"><span class="css">    <span class="selector-class">.container-1</span>&#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">text-align</span>: <span class="selector-tag">center</span>; <span class="comment">/* 内部的行内元素实现行内元素水平居中 */</span></span></span><br><span class="line"><span class="css">        <span class="selector-tag">line-height</span>: 200<span class="selector-tag">px</span>; <span class="comment">/* 利用高度等于行高实现行内元素垂直居中 */</span></span></span><br><span class="line">        height: 200px;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="comment">/* 第二种 */</span></span></span><br><span class="line"><span class="css">    <span class="selector-class">.container-2</span> &#123;</span></span><br><span class="line">        position: relative;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.container-2</span> <span class="selector-class">.item</span> &#123;</span></span><br><span class="line">        width: 300px;</span><br><span class="line">        height: 100px;</span><br><span class="line">        position: absolute;</span><br><span class="line">        left: 50%;</span><br><span class="line"><span class="css">        <span class="selector-tag">margin-left</span>: <span class="selector-tag">-150px</span>; <span class="comment">/* 必须知道自身尺寸，设置自身宽度一半 */</span></span></span><br><span class="line">        top: 50%;</span><br><span class="line">        margin-top: -50px;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="comment">/* 第三种（可能存在兼容性问题） */</span></span></span><br><span class="line"><span class="css">    <span class="selector-class">.container-3</span> &#123;</span></span><br><span class="line">        position: relative;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.container-3</span> <span class="selector-class">.item</span> &#123;</span></span><br><span class="line">        width: 200px;</span><br><span class="line">        height: 80px;</span><br><span class="line">        position: absolute;</span><br><span class="line">        left: 50%;</span><br><span class="line">        top: 50%;</span><br><span class="line"><span class="css">        <span class="selector-tag">transform</span>: <span class="selector-tag">translate</span>(<span class="selector-tag">-50</span>%, <span class="selector-tag">-50</span>%) <span class="comment">/* 无需知道自身尺寸（C3新属性） */</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="comment">/* 第四种（不需要知道子元素的尺寸，浏览器兼容性好） */</span></span></span><br><span class="line"><span class="css">    <span class="selector-class">.container-4</span> &#123;</span></span><br><span class="line">        position: relative;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.container-4</span> <span class="selector-class">.item</span> &#123;</span></span><br><span class="line">        width: 100px;</span><br><span class="line">        height: 50px;</span><br><span class="line">        position: absolute;</span><br><span class="line">        top: 0;</span><br><span class="line">        left: 0;</span><br><span class="line">        bottom: 0;</span><br><span class="line">        right: 0;</span><br><span class="line"><span class="css">        <span class="selector-tag">margin</span>: <span class="selector-tag">auto</span>; <span class="comment">/* 上下左右边距自动填充，实现水平垂直居中 */</span> </span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container container-1&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>一段文字<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container container-2&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span></span><br><span class="line">            this is item</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container container-3&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span></span><br><span class="line">            this is item</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container container-4&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span></span><br><span class="line">            this is item</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="CSS-图文样式"><a href="#CSS-图文样式" class="headerlink" title="CSS-图文样式"></a>CSS-图文样式</h2><h3 id="line-height如何继承？"><a href="#line-height如何继承？" class="headerlink" title="line- height如何继承？"></a>line- height如何继承？</h3><p>如下代码，p标签的行高将会是多少？</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span></span><br><span class="line">    body &#123;</span><br><span class="line">        font-size: 20px;</span><br><span class="line">        line-height: 200%;</span><br><span class="line">    &#125;</span><br><span class="line">    p &#123;</span><br><span class="line">        font-size: 16px;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>AAA<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>答案：40px（20px * 200% = 40px）</p>
<ul>
<li><p>写具体数值，如30px，则继承该值（比较好理解）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span></span><br><span class="line">    body &#123;</span><br><span class="line">        font-size: 20px;</span><br><span class="line">        line-height: 50px;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p &#123;</span><br><span class="line"><span class="css">        <span class="comment">/* 最终p标签的line-height为50px */</span></span></span><br><span class="line"><span class="css">        <span class="selector-tag">background-color</span>: <span class="selector-id">#ccc</span>;</span></span><br><span class="line">        font-size: 16px;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>写比例，如2/1.5，则继承该比例（比较好理解）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span></span><br><span class="line">    body &#123;</span><br><span class="line">        font-size: 20px;</span><br><span class="line"><span class="css">        <span class="selector-tag">line-height</span>: 1<span class="selector-class">.5</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p &#123;</span><br><span class="line"><span class="css">        <span class="comment">/* 最终p标签的line-height为24px（p的font-size * 1.5） */</span></span></span><br><span class="line"><span class="css">        <span class="selector-tag">background-color</span>: <span class="selector-id">#ccc</span>;</span></span><br><span class="line">        font-size: 16px;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>写百分比，如200%，则继承计算出来的值（考点）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span></span><br><span class="line">    body &#123;</span><br><span class="line">        font-size: 20px;</span><br><span class="line">        line-height: 200%;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p &#123;</span><br><span class="line"><span class="css">        <span class="comment">/* 最终p标签的line-height为40px（body的font-size * 200%） */</span></span></span><br><span class="line"><span class="css">        <span class="selector-tag">background-color</span>: <span class="selector-id">#ccc</span>;</span></span><br><span class="line">        font-size: 16px;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="CSS-响应式"><a href="#CSS-响应式" class="headerlink" title="CSS-响应式"></a>CSS-响应式</h2><h3 id="rem是什么？"><a href="#rem是什么？" class="headerlink" title="rem是什么？"></a>rem是什么？</h3><p>rem是一个长度单位</p>
<ul>
<li>px，绝对长度单位，最常用</li>
<li>em，相对长度单位，相对于父元素，特别不常用</li>
<li>rem，相对长度单位，相对于根元素（html），常用于响应式布局</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span></span><br><span class="line">    html &#123;</span><br><span class="line">        font-size: 100px;</span><br><span class="line">    &#125;</span><br><span class="line">    div &#123;</span><br><span class="line"><span class="css">        <span class="selector-tag">font-size</span>: 0<span class="selector-class">.16rem</span>; <span class="comment">/* 16px */</span></span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>rem可以应用在CSS中除了根元素以外的任意属性长度上（如width、height、line-height、padding等）</strong></p>
<h3 id="响应式布局的常见方案？"><a href="#响应式布局的常见方案？" class="headerlink" title="响应式布局的常见方案？"></a>响应式布局的常见方案？</h3><ul>
<li><p>由于rem是相对于根元素的长度单位，因此根元素不一样rem计算出来的就不一样</p>
</li>
<li><p>可以通过media-query查询不同屏幕的宽度，根据不同的屏幕宽度设置根元素font-size</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="keyword">@media</span> <span class="keyword">only</span> screen <span class="keyword">and</span> (<span class="attribute">max-width:</span> <span class="number">374px</span>) &#123;</span></span><br><span class="line"><span class="css">        <span class="comment">/* iphone5 或者更小的尺寸，以 iphone5 的宽度（320px）比例设置 font-size */</span></span></span><br><span class="line">        html &#123;</span><br><span class="line">            font-size: 86px;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="keyword">@media</span> <span class="keyword">only</span> screen <span class="keyword">and</span> (<span class="attribute">min-width:</span> <span class="number">375px</span>) <span class="keyword">and</span> (<span class="attribute">max-width:</span> <span class="number">413px</span>) &#123;</span></span><br><span class="line"><span class="css">        <span class="comment">/* iphone6/7/8 和 iphone x */</span></span></span><br><span class="line">        html &#123;</span><br><span class="line">            font-size: 100px;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="keyword">@media</span> <span class="keyword">only</span> screen <span class="keyword">and</span> (<span class="attribute">min-width:</span> <span class="number">414px</span>) &#123;</span></span><br><span class="line"><span class="css">        <span class="comment">/* iphone6p 或者更大的尺寸，以 iphone6p 的宽度（414px）比例设置 font-size */</span></span></span><br><span class="line">        html &#123;</span><br><span class="line">            font-size: 110px;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    body &#123;</span><br><span class="line"><span class="css">        <span class="comment">/* 在iPhone6上是16px，在iPhone5上小一些，iPhone6p上会大一些 */</span></span></span><br><span class="line"><span class="css">        <span class="selector-tag">font-size</span>: 0<span class="selector-class">.16rem</span>; </span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-id">#div1</span> &#123;</span></span><br><span class="line">        width: 1rem;</span><br><span class="line"><span class="css">        <span class="selector-tag">background-color</span>: <span class="selector-id">#ccc</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div1&quot;</span>&gt;</span></span><br><span class="line">        this is div</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>关于比例：375px / 320px  = 100px / 86px，100px / 110px = 375px / 414px，以这个为依据（实际应用中尺寸根据这三个就已经可以适配安卓与苹果，如果需要再精细就按需求增加媒体查询）</strong></p>
<h3 id="CSS-响应式-vw-vh"><a href="#CSS-响应式-vw-vh" class="headerlink" title="CSS-响应式-vw/vh"></a>CSS-响应式-vw/vh</h3><ul>
<li><p>针对rem的弊端（并非贬义词，是一个现象或者说是特性，适用于尺寸跨度比较大的）</p>
<p><strong>rem的弊端：“阶梯” 性（通过媒体查询一级一级类似台阶一样的设置根元素的尺寸大小）</strong></p>
</li>
</ul>
<ul>
<li><p>网页视口尺寸</p>
<p><strong>window.screen.height // 屏幕高度（整个手机屏幕显示区域的高度）</strong><br><strong>window.innerHeight // 网页视口高度（打开网页后去掉浏览器的上下的头和下巴）</strong><br><strong>document.body.clientHeight // body高度（网页内容高度）</strong></p>
</li>
</ul>
<ul>
<li><p>vw-vh</p>
<p><strong>vh网页视口高度的1/100</strong><br><strong>vw网页视口宽度的1/100</strong></p>
<p><strong>wmax取两者最大值；wmin取两者最小值</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    body &#123;</span><br><span class="line">        margin: 0;</span><br><span class="line">        padding: 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-id">#container</span> &#123;</span></span><br><span class="line">        background-color: red;</span><br><span class="line"><span class="css">        <span class="selector-tag">width</span>: 10<span class="selector-tag">vw</span>; <span class="comment">/* 网页视口宽度的1/10 */</span> </span></span><br><span class="line"><span class="css">        <span class="selector-tag">height</span>: 10<span class="selector-tag">vh</span>; <span class="comment">/* 网页视口高度的1/10 */</span></span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// window.innerHeight === 100vh</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// window.innerWidth === 100vw</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="关于CSS动画"><a href="#关于CSS动画" class="headerlink" title="关于CSS动画"></a>关于CSS动画</h2><p>并不是面试的重点，除非面试是一个专门做动画的职位</p>
]]></content>
      <categories>
        <category>前端面试题</category>
      </categories>
      <tags>
        <tag>知识点总结</tag>
        <tag>HTML、CSS面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面试题总结-面试真题</title>
    <url>/2020/12/12/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93-%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98/</url>
    <content><![CDATA[<ul>
<li><strong>网上的高频 JS 初级面试题</strong></li>
<li><strong>验证和复习之前学过的知识</strong></li>
<li><strong>补充其他技能，如正则表达式、数组 API</strong></li>
</ul>
<a id="more"></a>

<h1 id="题目-1"><a href="#题目-1" class="headerlink" title="题目 - 1"></a>题目 - 1</h1><h2 id="var、let、const-的区别"><a href="#var、let、const-的区别" class="headerlink" title="var、let、const 的区别"></a>var、let、const 的区别</h2><ul>
<li>var 是 ES5 语法， let、const 是 ES6 语法；var 有变量提升</li>
<li>var 和 let 是变量，可修改； const 是常量，不可修改；</li>
<li>let、const 有块级作用域，var 没有</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 变量提升 ES5</span></span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">200</span></span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="comment">// var a</span></span><br><span class="line"><span class="comment">// console.log(a) // undefined</span></span><br><span class="line"><span class="comment">// a = 200</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 块级作用域</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> j = i + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(j) <span class="comment">// not defined</span></span><br></pre></td></tr></table></figure>

<h2 id="typeof-返回哪些类型"><a href="#typeof-返回哪些类型" class="headerlink" title="typeof 返回哪些类型"></a>typeof 返回哪些类型</h2><ul>
<li>undefined、string、number、boolean、symbol  - （均为值类型）</li>
<li>object（注意， typeof null === ‘object’） - （为引用类型）</li>
<li>function</li>
</ul>
<h2 id="列举强制类型转换和隐式类型转换"><a href="#列举强制类型转换和隐式类型转换" class="headerlink" title="列举强制类型转换和隐式类型转换"></a>列举强制类型转换和隐式类型转换</h2><ul>
<li>强制：parseInt、parseFloat、toString 等</li>
<li>隐式：if、逻辑运算、==、+ 拼接字符串</li>
</ul>
<h1 id="题目-2"><a href="#题目-2" class="headerlink" title="题目 - 2"></a>题目 - 2</h1><h2 id="手写深度比较，模拟-lodash-isEqual"><a href="#手写深度比较，模拟-lodash-isEqual" class="headerlink" title="手写深度比较，模拟 lodash.isEqual"></a>手写深度比较，模拟 lodash.isEqual</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实现如下效果</span></span><br><span class="line"><span class="keyword">const</span> obj1 = &#123; <span class="attr">a</span>: <span class="number">10</span>, <span class="attr">b</span>: &#123; <span class="attr">x</span>: <span class="number">100</span>, <span class="attr">y</span>: <span class="number">200</span> &#125; &#125;</span><br><span class="line"><span class="keyword">const</span> obj2 = &#123; <span class="attr">a</span>: <span class="number">10</span>, <span class="attr">b</span>: &#123; <span class="attr">x</span>: <span class="number">100</span>, <span class="attr">y</span>: <span class="number">200</span> &#125; &#125;</span><br><span class="line">isEqual(obj1, obj2) === <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断是否为对象或数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isObj</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> obj === <span class="string">&quot;object&quot;</span> &amp;&amp; obj !== <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 全相等（深度）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isEqual</span>(<span class="params">obj1, obj2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isObj(obj1) || !isObj(obj2)) &#123;</span><br><span class="line">        <span class="comment">// 值类型直接返回，参与 equal 的一般不会是函数</span></span><br><span class="line">        <span class="keyword">return</span> obj1 === obj2</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (obj1 === obj2) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment">// 两个都是对象或数组，并且不相等</span></span><br><span class="line">    <span class="comment">// 1. 先取出 obj1 和 obj2 的 keys，比较个数</span></span><br><span class="line">    <span class="keyword">const</span> obj1Keys = <span class="built_in">Object</span>.keys(obj1)</span><br><span class="line">    <span class="keyword">const</span> obj2Keys = <span class="built_in">Object</span>.keys(obj2)</span><br><span class="line">    <span class="keyword">if</span> (obj1Keys.length !== obj2Keys.length) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment">// 2. 以 obj1 为基准，和 obj2 依次递归比较</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj1) &#123;</span><br><span class="line">        <span class="comment">// 比较当前 key 的 value - 递归</span></span><br><span class="line">        <span class="keyword">const</span> res = isEqual(obj1[key], obj2[key])</span><br><span class="line">        <span class="keyword">if</span> (!res) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 全相等</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="split-和-join-的区别"><a href="#split-和-join-的区别" class="headerlink" title="split() 和 join() 的区别"></a>split() 和 join() 的区别</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一个是拆分数组，一个是拼接</span></span><br><span class="line"><span class="string">&quot;1-2-3&quot;</span>.split(<span class="string">&quot;-&quot;</span>)  <span class="comment">// [1, 2, 3]</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].join(<span class="string">&#x27;-&#x27;</span>) <span class="comment">// &#x27;1-2-3&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="数组的-pop、push、unshift、shift-分别是什么"><a href="#数组的-pop、push、unshift、shift-分别是什么" class="headerlink" title="数组的 pop、push、unshift、shift 分别是什么"></a>数组的 pop、push、unshift、shift 分别是什么</h2><p><em>回答逻辑：功能、返回值、是否对原数组造成影响</em></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// pop: 刨除数组最后一个，并且返回刨除的元素，原数组被刨除元素消失</span></span><br><span class="line"><span class="keyword">const</span> popRes = arr.pop()</span><br><span class="line"><span class="built_in">console</span>.log(popRes, arr) <span class="comment">// 40 &amp; [10, 20, 30]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// push: 向数组最后追加元素，返回的是数组的 length，原数组引入追加元素</span></span><br><span class="line"><span class="keyword">const</span> pushRes = arr.push(<span class="number">50</span>)</span><br><span class="line"><span class="built_in">console</span>.log(pushRes, arr) <span class="comment">// 5 &amp; [10, 20, 30, 40, 50]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// unshift: 在最前面插入一个传入的元素，返回数组的 length，原数组在最前面引入该元素</span></span><br><span class="line"><span class="keyword">const</span> unshiftRes = arr.unshift(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">console</span>.log(unshiftRes, arr) <span class="comment">// 5 &amp; [5, 10, 20, 30, 40]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// shift: 在原数组最前面取出一个元素，返回取出来的数组元素，原数组去掉取出的元素</span></span><br><span class="line"><span class="keyword">const</span> shiftRes = arr.shift()</span><br><span class="line"><span class="built_in">console</span>.log(shiftRes, arr) <span class="comment">// 10 &amp; [20, 30, 40]</span></span><br></pre></td></tr></table></figure>

<h2 id="扩展-数组的-API，有哪些是纯函数"><a href="#扩展-数组的-API，有哪些是纯函数" class="headerlink" title="扩展 - 数组的 API，有哪些是纯函数"></a>扩展 - 数组的 API，有哪些是纯函数</h2><p>纯函数：1. 不改变源数组（没有副作用）；2. 返回一个数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// concat - 追加一个数组，并且无论原数组或者新数组做任何改变，互不影响</span></span><br><span class="line"><span class="keyword">const</span> arr1 = arr.concat([<span class="number">50</span>, <span class="number">60</span>, <span class="number">70</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// map: 针对每个数组元素进行操作，返回新的数组，互不影响</span></span><br><span class="line"><span class="keyword">const</span> arr2 = arr.map(<span class="function">(<span class="params">num</span>) =&gt;</span> num * <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// filter: 针对原数组进行条件过滤，返回新的数组，互不影响</span></span><br><span class="line"><span class="keyword">const</span> arr3 = arr.filter(<span class="function">(<span class="params">num</span>) =&gt;</span> num &gt; <span class="number">25</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// slice: 类似做了一个深拷贝，返回一个和原数组一样的数组，二者互不影响</span></span><br><span class="line"><span class="keyword">const</span> arr4 = arr.slice()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非纯函数</span></span><br><span class="line"><span class="comment">// push pop shift unshift</span></span><br><span class="line"><span class="comment">// forEach（并非返回一个数组）</span></span><br><span class="line"><span class="comment">// some every</span></span><br><span class="line"><span class="comment">// reduce</span></span><br></pre></td></tr></table></figure>

<h1 id="题目-3"><a href="#题目-3" class="headerlink" title="题目 - 3"></a>题目 - 3</h1><h2 id="数组-slice-和-splice-的区别"><a href="#数组-slice-和-splice-的区别" class="headerlink" title="数组 slice 和 splice 的区别"></a>数组 slice 和 splice 的区别</h2><ul>
<li>功能区别（slice - 切片， splice - 剪接）</li>
<li>参数和返回值</li>
<li>是否纯函数</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// slice 纯函数</span></span><br><span class="line"><span class="keyword">const</span> arr1 = arr.slice()       <span class="comment">// 不传参数类似深拷贝</span></span><br><span class="line"><span class="keyword">const</span> arr2 = arr.slice(<span class="number">1</span>, <span class="number">4</span>)   <span class="comment">// starIndex 与 endIndex   arr2 = [20, 30, 40]</span></span><br><span class="line"><span class="keyword">const</span> arr3 = arr.slice(<span class="number">2</span>)      <span class="comment">// 从 index 为 2 截取到最后 arr3 = [30, 40, 50]</span></span><br><span class="line"><span class="keyword">const</span> arr4 = arr.slice(-<span class="number">3</span>)     <span class="comment">// 从最后开始截，截最后三个  arr4 = [30, 40, 50]</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// splice 非纯函数(有副作用)</span></span><br><span class="line"><span class="comment">// 剪切并且填</span></span><br><span class="line"><span class="keyword">const</span> spliceRes = arr.splice(<span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>) <span class="comment">// 从 index 1，长度 2，剪切出来，再把后面所有参数放到剪切的位子</span></span><br><span class="line"><span class="built_in">console</span>.log(spliceRes, arr)  <span class="comment">// [20, 30] &amp; [10, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, 40, 50]</span></span><br><span class="line"><span class="comment">// 只剪切不填</span></span><br><span class="line"><span class="keyword">const</span> spliceRes = arr.splice(<span class="number">1</span>, <span class="number">2</span>)   <span class="comment">// arr = [10, 40, 50]  spliceRes = [20, 30]</span></span><br><span class="line"><span class="comment">// 增加但不移除</span></span><br><span class="line"><span class="keyword">const</span> spliceRes2 = arr.splice(<span class="number">1</span>, <span class="number">0</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>)  <span class="comment">// arr = [10, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, 20, 30, 40, 50]  spliceRes2 = []</span></span><br></pre></td></tr></table></figure>



<h2 id="10-20-30-map-parseInt-返回结果是什么"><a href="#10-20-30-map-parseInt-返回结果是什么" class="headerlink" title="[10,20,30].map(parseInt)   返回结果是什么"></a>[10,20,30].map(parseInt)   返回结果是什么</h2><p><em>网红题</em></p>
<ul>
<li>map 的参数和返回值</li>
<li>parseInt 参数和返回值（可参考：<a href="https://www.w3school.com.cn/js/jsref_parseint.asp">parseInt函数</a>， <a href="https://www.cnblogs.com/anjey/archive/2012/04/13/2445430.html">浅谈 js中parseInt函数的解析</a>）</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> res = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>].map(<span class="built_in">parseInt</span>) <span class="comment">// res = [10, NaN, NaN]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 拆解（考察重点）, 与上面的写法完全一样</span></span><br><span class="line"><span class="comment">// const res = [10, 20, 30].map((item, index) =&gt; &#123;</span></span><br><span class="line"><span class="comment">//     return parseInt(item, index) // index 表示进制</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br></pre></td></tr></table></figure>



<h2 id="ajax-请求-get-和-post-的区别"><a href="#ajax-请求-get-和-post-的区别" class="headerlink" title="ajax 请求 get 和 post 的区别"></a>ajax 请求 get 和 post 的区别</h2><ul>
<li>get 一般用于查询操作，post 一般用户提交操作</li>
<li>get 参数拼接在 url 上，post 放在请求体内（数据体积可更大）</li>
<li>安全性∶ post 易于防止 CSRF</li>
</ul>
<h1 id="题目-4"><a href="#题目-4" class="headerlink" title="题目 - 4"></a>题目 - 4</h1><h2 id="函数-call-和-apply-的区别"><a href="#函数-call-和-apply-的区别" class="headerlink" title="函数 call 和 apply 的区别"></a>函数 call 和 apply 的区别</h2><ul>
<li>传参方式不同：call 是从第二个参数开始，依次传入，apply 是可以传入一个数组</li>
</ul>
<h2 id="事件代理（委托）是什么（重点）"><a href="#事件代理（委托）是什么（重点）" class="headerlink" title="事件代理（委托）是什么（重点）"></a>事件代理（委托）是什么（重点）</h2><ul>
<li>把原本需要绑定的事件委托给父元素，让父元素担当事件监听职务。原理是DOM元素事件冒泡。使用事件代理好处是可以提高性能</li>
<li>可以大量节省内存占用，减少事件注册</li>
<li>可以实现当新增子对象时无需再次对其绑定</li>
</ul>
<h2 id="闭包是什么，有什么特性，有什么负面影响"><a href="#闭包是什么，有什么特性，有什么负面影响" class="headerlink" title="闭包是什么，有什么特性，有什么负面影响"></a>闭包是什么，有什么特性，有什么负面影响</h2><ul>
<li>回顾作用域和自由变量</li>
<li>回顾闭包应用场景：作为参数被传入，作为返回值被返回</li>
<li>回顾：自由变量的查找，要在函数定义的地方（而非执行的地方）</li>
<li>影响：变量会常驻内存，得不到释放。闭包不要乱用</li>
</ul>
<h1 id="题目-5"><a href="#题目-5" class="headerlink" title="题目 - 5"></a>题目 - 5</h1><h2 id="如何阻止事件冒泡和默认行为"><a href="#如何阻止事件冒泡和默认行为" class="headerlink" title="如何阻止事件冒泡和默认行为"></a>如何阻止事件冒泡和默认行为</h2><ul>
<li>event.stopPropagation()</li>
<li>event.preventDefault()</li>
</ul>
<h2 id="查找、添加、删除、移动-DOM-节点的方法"><a href="#查找、添加、删除、移动-DOM-节点的方法" class="headerlink" title="查找、添加、删除、移动 DOM 节点的方法"></a>查找、添加、删除、移动 DOM 节点的方法</h2><ul>
<li>n 个 API</li>
</ul>
<h2 id="如何减少-DOM-操作"><a href="#如何减少-DOM-操作" class="headerlink" title="如何减少 DOM 操作"></a>如何减少 DOM 操作</h2><ul>
<li>缓存 DOM 查询结果</li>
<li>多次 DOM 操作，合并到一次插入（创建 Fragment 文档片段）</li>
</ul>
<h1 id="题目-6"><a href="#题目-6" class="headerlink" title="题目 - 6"></a>题目 - 6</h1><h2 id="解释-jsonp-的原理，为何它不是真正的-ajax"><a href="#解释-jsonp-的原理，为何它不是真正的-ajax" class="headerlink" title="解释 jsonp 的原理，为何它不是真正的 ajax"></a>解释 jsonp 的原理，为何它不是真正的 ajax</h2><ul>
<li>浏览器的同源策略（服务端没有同源策略）和跨域</li>
<li>哪些 html 标签能绕过跨域（img、script）</li>
<li>jsonp 没有用到 XMLHTTPRequest API，它可以说是一个 JS 加载的变种方案来实现跨域信息的交换</li>
</ul>
<h2 id="document-load-和-ready-的区别"><a href="#document-load-和-ready-的区别" class="headerlink" title="document load 和 ready 的区别"></a>document load 和 ready 的区别</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;load&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 页面的全部资源加载完才会执行，包括图片、视频等</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;DOMContentLoaded&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// DOM 渲染完即可执行，此时图片、视频还可能没有加载完</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="和-的不同"><a href="#和-的不同" class="headerlink" title="== 和 === 的不同"></a>== 和 === 的不同</h2><ul>
<li>== 会尝试类型转换</li>
<li>=== 严格相等</li>
<li>哪些场景才用 ==   （== null）</li>
</ul>
<h1 id="题目-7"><a href="#题目-7" class="headerlink" title="题目 - 7"></a>题目 - 7</h1><h2 id="函数声明和函数表达式的区别"><a href="#函数声明和函数表达式的区别" class="headerlink" title="函数声明和函数表达式的区别"></a>函数声明和函数表达式的区别</h2><ul>
<li><p>函数声明：function fn() {…}</p>
</li>
<li><p>函数表达式：const fn = function() {…}</p>
</li>
<li><p>函数声明会在代码执行前预加载(函数提升，直接函数整体加载完成)，而函数表达式不会</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="keyword">const</span> res = sum(<span class="number">10</span>, <span class="number">20</span>)  <span class="comment">// 30</span></span><br><span class="line"><span class="built_in">console</span>.log(res)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数表达式</span></span><br><span class="line"><span class="keyword">var</span> res = sum(<span class="number">10</span>, <span class="number">20</span>)  <span class="comment">// sum not a function</span></span><br><span class="line"><span class="built_in">console</span>.log(res)</span><br><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="new-Object-和-Object-create-的区别"><a href="#new-Object-和-Object-create-的区别" class="headerlink" title="new Object() 和 Object.create() 的区别"></a>new Object() 和 Object.create() 的区别</h2><p><em>网红题</em></p>
<ul>
<li><p>{} 等同于 new Object()，原型 Object.prototype</p>
</li>
<li><p>Object.create(null) 没有原型(必须传递参数，null代表空对象)</p>
</li>
<li><p>Object.create({…}) 可指定原型</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// obj1、obj2 都有隐式原型，并且指向 Object 构造函数的显式原型</span></span><br><span class="line"><span class="keyword">const</span> obj1 = &#123;</span><br><span class="line">    a: <span class="number">10</span>,</span><br><span class="line">    b: <span class="number">20</span>,</span><br><span class="line">    <span class="function"><span class="title">sum</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.a + <span class="built_in">this</span>.b</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj2 = <span class="keyword">new</span> <span class="built_in">Object</span>(&#123;</span><br><span class="line">    a: <span class="number">10</span>,</span><br><span class="line">    b: <span class="number">20</span>,</span><br><span class="line">    <span class="function"><span class="title">sum</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.a + <span class="built_in">this</span>.b</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// const obj21 = new Object(obj1)  obj1 === obj2  =&gt; true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj3 = <span class="built_in">Object</span>.create(<span class="literal">null</span>) <span class="comment">// &#123;&#125; 空对象并且展开后显示 No properties</span></span><br><span class="line"><span class="keyword">const</span> obj4 = <span class="keyword">new</span> <span class="built_in">Object</span>() <span class="comment">// &#123;&#125; 有隐式原型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj5 = <span class="built_in">Object</span>.create(&#123;</span><br><span class="line">    a: <span class="number">10</span>,</span><br><span class="line">    b: <span class="number">20</span>,</span><br><span class="line">    <span class="function"><span class="title">sum</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.a + <span class="built_in">this</span>.b</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 虽然 obj5 是空对象 &#123;&#125;，但是 obj5.a = 10，这是因为 obj5 的原型里面包含 a、b、sum</span></span><br><span class="line"><span class="comment">// 所以可以得出结论，当用 create 创建的时候，会把 create 里面的东西放在一个空对象的原型中</span></span><br><span class="line"><span class="comment">// 也就是 Object.create() 会新建一个空对象，然后把空对象的原型挂到传入的对象上</span></span><br><span class="line"><span class="comment">// 如果传入 null 就没有原型</span></span><br><span class="line"><span class="keyword">const</span> obj6 = <span class="built_in">Object</span>.create(obj1) <span class="comment">// obj6 原型指向了 obj1，obj1 改变 obj6 也变</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="关于-this-的场景题"><a href="#关于-this-的场景题" class="headerlink" title="关于 this 的场景题"></a>关于 this 的场景题</h2><ul>
<li><p>只有执行的时候才能确定 this 的指向，而非定义时确定的 this</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> User = &#123;</span><br><span class="line">    count: <span class="number">1</span>,</span><br><span class="line">    getCount: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.count</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(User.getCount()) <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">const</span> func = User.getCount</span><br><span class="line"><span class="built_in">console</span>.log(func()) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="题目-8"><a href="#题目-8" class="headerlink" title="题目 - 8"></a>题目 - 8</h1><h2 id="关于作用域和自由变量的场景题-1"><a href="#关于作用域和自由变量的场景题-1" class="headerlink" title="关于作用域和自由变量的场景题 - 1"></a>关于作用域和自由变量的场景题 - 1</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> i</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i)</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3 个 4</span></span><br></pre></td></tr></table></figure>

<h2 id="判断字符串以字母开头，后面字母数字下划线，长度-6-30"><a href="#判断字符串以字母开头，后面字母数字下划线，长度-6-30" class="headerlink" title="判断字符串以字母开头，后面字母数字下划线，长度 6 - 30"></a>判断字符串以字母开头，后面字母数字下划线，长度 6 - 30</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> reg = <span class="regexp">/^[a-zA-Z]\w&#123;6,29&#125;$/</span></span><br></pre></td></tr></table></figure>

<p><a href="https://www.runoob.com/regexp/regexp-syntax.html">正则表达式(菜鸟教程)</a></p>
<p><a href="https://deerchao.cn/tutorials/regex/regex.htm#top">正则表达式30分钟入门教程</a></p>
<h2 id="关于作用域和自由变量的场景题-2"><a href="#关于作用域和自由变量的场景题-2" class="headerlink" title="关于作用域和自由变量的场景题 - 2"></a>关于作用域和自由变量的场景题 - 2</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">100</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(a) <span class="comment">// 100</span></span><br><span class="line">    a = <span class="number">10</span></span><br><span class="line">    alert(a) <span class="comment">// 10</span></span><br><span class="line">&#125;</span><br><span class="line">test()</span><br><span class="line">alert(a) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<h1 id="题目-9"><a href="#题目-9" class="headerlink" title="题目 - 9"></a>题目 - 9</h1><h2 id="手写字符串-trim-方法，保证浏览器兼容性"><a href="#手写字符串-trim-方法，保证浏览器兼容性" class="headerlink" title="手写字符串 trim 方法，保证浏览器兼容性"></a>手写字符串 trim 方法，保证浏览器兼容性</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原型、this、正则</span></span><br><span class="line"><span class="built_in">String</span>.prototype.trim = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.replace(<span class="regexp">/^\s+/</span>, <span class="string">&quot;&quot;</span>).replace(<span class="regexp">/\s+$/</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="如何获取多个数字中的最大值"><a href="#如何获取多个数字中的最大值" class="headerlink" title="如何获取多个数字中的最大值"></a>如何获取多个数字中的最大值</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">maxValue</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// const nums = Array.prototype.slice.call(arguments) // 变为数组</span></span><br><span class="line">    <span class="keyword">const</span> nums = [...arguments]</span><br><span class="line">    <span class="keyword">let</span> max = <span class="number">0</span></span><br><span class="line">    nums.forEach(<span class="function">(<span class="params">n</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; max) &#123;</span><br><span class="line">            max = n</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(maxValue(<span class="number">3</span>, <span class="number">12</span>, <span class="number">4131</span>, <span class="number">31</span>))</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.max(<span class="number">10</span>, <span class="number">30</span>, <span class="number">20</span>, <span class="number">40</span>) <span class="comment">// 以及 Math.min</span></span><br></pre></td></tr></table></figure>

<h2 id="如何用-JS-实现继承"><a href="#如何用-JS-实现继承" class="headerlink" title="如何用 JS 实现继承"></a>如何用 JS 实现继承</h2><ul>
<li>class 继承</li>
<li>prototype 继承</li>
</ul>
<h1 id="题目-10"><a href="#题目-10" class="headerlink" title="题目 - 10"></a>题目 - 10</h1><h2 id="如何捕获-JS-程序中的异常"><a href="#如何捕获-JS-程序中的异常" class="headerlink" title="如何捕获 JS 程序中的异常"></a>如何捕获 JS 程序中的异常</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// todo</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(ex); <span class="comment">// 手动捕获 catch</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// todo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自动捕获</span></span><br><span class="line"><span class="comment">//                          信息     源码     行号	列号	  错误栈</span></span><br><span class="line"><span class="built_in">window</span>.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">message, source, lineNum, colNum, error</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 第一，对跨域的 js，如 CDN 的，不会有详细的报错信息</span></span><br><span class="line">    <span class="comment">// 第二，对于压缩的 js，还要配合 sourceMap 反查到未压缩代码的行、列</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="什么是-JSON"><a href="#什么是-JSON" class="headerlink" title="什么是 JSON"></a>什么是 JSON</h2><ul>
<li>json 是一种数据格式，本质是一段字符串</li>
<li>json 格式和 JS 对象结构一致，对 JS 语言更友好</li>
<li>window.JSON 是一个全局对象：JSON.stringify、JSON.parse</li>
</ul>
<h2 id="获取当前页面-url-参数"><a href="#获取当前页面-url-参数" class="headerlink" title="获取当前页面 url 参数"></a>获取当前页面 url 参数</h2><ul>
<li><p>传统方式，查找 location.search</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传统方式（也可用拆分方式）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">query</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 去掉第一个问号，并截取到最后</span></span><br><span class="line">    <span class="keyword">const</span> search = location.search.substr(<span class="number">1</span>)</span><br><span class="line">    <span class="comment">// search: &#x27;a=10&amp;b=20&amp;c=30&#x27;</span></span><br><span class="line">    <span class="comment">// 括号为组，最后查询到的第一个参数是匹配结果，剩下的为组的结果</span></span><br><span class="line">    <span class="comment">// [^&amp;]*: 匹配非 &amp; 符号的零个或无数个</span></span><br><span class="line">    <span class="keyword">const</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">`(^|&amp;)<span class="subst">$&#123;name&#125;</span>=([^&amp;]*)(&amp;|$)`</span>, <span class="string">&quot;i&quot;</span>) <span class="comment">// i 为不区分大小写</span></span><br><span class="line">    <span class="keyword">const</span> res = search.match(reg)</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res[<span class="number">2</span>]</span><br><span class="line">&#125;</span><br><span class="line">query(<span class="string">&quot;d&quot;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>新 API，URLSearchParams</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// URLSearchParams（有浏览器兼容问题，在高版本浏览器会好一些）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">query</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> search = location.search</span><br><span class="line">    <span class="keyword">const</span> p = <span class="keyword">new</span> URLSearchParams(search)</span><br><span class="line">    <span class="keyword">return</span> p.get(name)</span><br><span class="line">&#125;</span><br><span class="line">query(<span class="string">&quot;a&quot;</span>)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="题目-11"><a href="#题目-11" class="headerlink" title="题目 - 11"></a>题目 - 11</h1><h2 id="将-url-参数解析为-JS-对象"><a href="#将-url-参数解析为-JS-对象" class="headerlink" title="将 url 参数解析为 JS 对象"></a>将 url 参数解析为 JS 对象</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传统方式，分析 search</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">queryToObj</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> res = &#123;&#125;</span><br><span class="line">    <span class="keyword">const</span> search = location.search.substr(<span class="number">1</span>) <span class="comment">// 去掉前面的 &#x27;?&#x27;</span></span><br><span class="line">    search.split(<span class="string">&quot;&amp;&quot;</span>).forEach(<span class="function">(<span class="params">paramStr</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> arr = paramStr.split(<span class="string">&quot;=&quot;</span>)</span><br><span class="line">        <span class="keyword">const</span> key = arr[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">const</span> val = arr[<span class="number">1</span>]</span><br><span class="line">        res[key] = val</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line">queryToObj()</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 URLSearchParams</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">queryToObj</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> res = &#123;&#125;</span><br><span class="line">    <span class="keyword">const</span> pList = <span class="keyword">new</span> URLSearchParams(location.search)</span><br><span class="line">    <span class="built_in">console</span>.log(pList)</span><br><span class="line">    pList.forEach(<span class="function">(<span class="params">val, key</span>) =&gt;</span> &#123;</span><br><span class="line">        res[key] = val</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line">queryToObj()</span><br></pre></td></tr></table></figure>

<h2 id="手写数组-flaten，考虑多层级"><a href="#手写数组-flaten，考虑多层级" class="headerlink" title="手写数组 flaten，考虑多层级"></a>手写数组 flaten，考虑多层级</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一层深度的数组，如：[10, 20, 30, [40, 50]]</span></span><br><span class="line"><span class="comment">// 可以用 concat [].concat(10, 20, 30, [40, 50]), 或</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.concat.apply([], [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, [<span class="number">40</span>, <span class="number">50</span>]])</span><br><span class="line"><span class="comment">// [10, 20, 30, 40, 50]</span></span><br><span class="line"><span class="comment">// 但是多层就这种方法就不可行，需要用到递归</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不管多少层，都按照顺序拍平到一个数组里面</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flat</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 验证 arr 中还有没有深层数组</span></span><br><span class="line">    <span class="keyword">const</span> isDeepArray = arr.some(<span class="function">(<span class="params">item</span>) =&gt;</span> item <span class="keyword">instanceof</span> <span class="built_in">Array</span>)</span><br><span class="line">    <span class="keyword">if</span> (!isDeepArray) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr <span class="comment">// 已经是平的</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="built_in">Array</span>.prototype.concat.apply([], arr)</span><br><span class="line">    <span class="keyword">return</span> flat(res) <span class="comment">// 递归</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">flat([<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>], <span class="number">9</span>], <span class="number">10</span>, [<span class="number">11</span>, <span class="number">12</span>]])</span><br><span class="line"><span class="comment">// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]</span></span><br></pre></td></tr></table></figure>

<h2 id="数组去重（网红题）"><a href="#数组去重（网红题）" class="headerlink" title="数组去重（网红题）"></a>数组去重（网红题）</h2><ul>
<li><p>传统方式，遍历元素挨个比较、去重</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> res = []</span><br><span class="line">    arr.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 未找到该元素 indexof（这个方法本身也是一种遍历） 返回 -1</span></span><br><span class="line">        <span class="comment">// 相当于遍历了两次，算法效率比较低</span></span><br><span class="line">        <span class="keyword">if</span> (res.indexOf(item) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            res.push(item)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line">unique([<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 Set</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 set （无序结构，不能重复，因此无需遍历）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>(arr)</span><br><span class="line">    <span class="keyword">return</span> [...set]</span><br><span class="line">&#125;</span><br><span class="line">unique([<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br></pre></td></tr></table></figure>
</li>
<li><p>考虑计算效率</p>
<p><strong>使用 set</strong></p>
</li>
</ul>
<h1 id="题目-12"><a href="#题目-12" class="headerlink" title="题目 - 12"></a>题目 - 12</h1><h2 id="手写深拷贝（重点）"><a href="#手写深拷贝（重点）" class="headerlink" title="手写深拷贝（重点）"></a>手写深拷贝（重点）</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&quot;object&quot;</span> || obj == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// obj 是 null，或者不是对象或数组，直接返回</span></span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化返回结果</span></span><br><span class="line">    <span class="keyword">let</span> result</span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="built_in">Array</span>) &#123;</span><br><span class="line">        result = []</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result = &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="comment">// 保证 key 不是原型的属性</span></span><br><span class="line">        <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">            <span class="comment">// 递归调用</span></span><br><span class="line">            result[key] = deepClone(obj[key])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回结果</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意，Object.assign 是追加信息，不是深拷贝！！！</span></span><br><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line">    a: <span class="number">100</span>,</span><br><span class="line">    b: &#123;</span><br><span class="line">        c: <span class="number">200</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.assign(a, &#123; <span class="attr">d</span>: <span class="number">40</span> &#125;)</span><br><span class="line">a = &#123;</span><br><span class="line">    a: <span class="number">100</span>,</span><br><span class="line">    b: &#123;</span><br><span class="line">        c: <span class="number">200</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    d: <span class="number">40</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line">    a: <span class="number">100</span>,</span><br><span class="line">    b: &#123;</span><br><span class="line">        c: <span class="number">200</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    a: <span class="number">100</span>,</span><br><span class="line">    b: &#123;</span><br><span class="line">        c: <span class="number">200</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj1 = <span class="built_in">Object</span>.assign(&#123;&#125;, obj1, &#123; <span class="attr">d</span>: <span class="number">300</span> &#125;)</span><br><span class="line">obj1 = &#123;</span><br><span class="line">    a: <span class="number">100</span>,</span><br><span class="line">    b: &#123;</span><br><span class="line">        c: <span class="number">200</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    d: <span class="number">300</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 此时浅层级改 obj.a = 400 , obj1的浅层级不变 obj1.a = 100</span></span><br><span class="line"><span class="comment">// 但如果改深层级 obj.b.c = 500, obj1 的深层级也变 obj1.b.c = 500</span></span><br><span class="line"><span class="comment">// 由此可见 Object.assign 拷贝的只是 obj 的第一层级</span></span><br><span class="line"><span class="comment">// 深层级就不行了</span></span><br></pre></td></tr></table></figure>

<h2 id="介绍一下-RAF-（requestAnimationFrame）"><a href="#介绍一下-RAF-（requestAnimationFrame）" class="headerlink" title="介绍一下 RAF （requestAnimationFrame）"></a>介绍一下 RAF （requestAnimationFrame）</h2><ul>
<li>想要动画流畅，更新频率要 60帧/s，即 16.67ms 更新一次视图</li>
<li>setTimeout 要手动控制频率，而 RAF 浏览器会自动控制</li>
<li>后台标签或隐藏 ifram 中，RAF 会暂停，而 setTimeout 依然执行</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// html</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&lt;style&gt;</span></span><br><span class="line"><span class="comment">    #div1 &#123;</span></span><br><span class="line"><span class="comment">        width: 100px;</span></span><br><span class="line"><span class="comment">        height: 50px;</span></span><br><span class="line"><span class="comment">        background-color: red;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&lt;/style&gt;</span></span><br><span class="line"><span class="comment">&lt;body&gt;</span></span><br><span class="line"><span class="comment">    &lt;div id=&quot;div1&quot;&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="comment">&lt;/body&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3s 把宽度从 100px 变为 640px ，即增加 540px</span></span><br><span class="line"><span class="comment">// 60帧/s ，3s 180 帧 ，每次变化 3px</span></span><br><span class="line"><span class="keyword">const</span> $div1 = $(<span class="string">&quot;#div1&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> curWidth = <span class="number">100</span></span><br><span class="line"><span class="keyword">const</span> maxWidth = <span class="number">640</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// setTimeout</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">animate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    curWidth = curWidth + <span class="number">3</span></span><br><span class="line">    $div1.css(<span class="string">&quot;width&quot;</span>, curWidth)</span><br><span class="line">    <span class="keyword">if</span> (curWidth &lt; maxWidth) &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(animate, <span class="number">16.7</span>) <span class="comment">// 问题在于自己控制时间</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">animate()</span><br></pre></td></tr></table></figure>

<p><em><a href="https://www.bootcdn.cn/">bootcdn</a></em></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// RAF</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">animate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    curWidth = curWidth + <span class="number">3</span></span><br><span class="line">    $div1.css(<span class="string">&#x27;width&#x27;</span>, curWidth)</span><br><span class="line">    <span class="keyword">if</span> (curWidth &lt; maxWidth) &#123;</span><br><span class="line">        <span class="built_in">window</span>.requestAnimationFrame(animate) <span class="comment">// 时间不用自己控制，浏览器控制</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">animate()</span><br></pre></td></tr></table></figure>

<h2 id="前端性能如何优化？一般从哪几个方面考虑？"><a href="#前端性能如何优化？一般从哪几个方面考虑？" class="headerlink" title="前端性能如何优化？一般从哪几个方面考虑？"></a>前端性能如何优化？一般从哪几个方面考虑？</h2><ul>
<li>原则：多使用内存、缓存，减少计算、减少网络请求</li>
<li>方向：加载页面，页面渲染，页面操作流畅度</li>
</ul>
]]></content>
      <categories>
        <category>前端面试题</category>
      </categories>
      <tags>
        <tag>知识点总结</tag>
        <tag>初级前端面试真题</tag>
      </tags>
  </entry>
</search>
